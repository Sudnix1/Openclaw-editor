<div class="container-fluid mt-4">
  <div class="row">
    <div class="col-12">
      <h2 class="mb-4">
        <i class="bi bi-file-earmark-spreadsheet"></i> GPT XLSX Manager
      </h2>
      <p class="text-muted">
        Upload XLSX files generated by your GPT with pre-analyzed Pinterest data.
        Each keyword will get 1 blog post and 2 different Pinterest pins with unique Midjourney images.
      </p>
    </div>
  </div>

  <!-- Upload Section -->
  <div class="row mt-4">
    <div class="col-md-6">
      <div class="card">
        <div class="card-header bg-primary text-white">
          <h5 class="mb-0"><i class="bi bi-upload"></i> Step 1: Upload XLSX File</h5>
        </div>
        <div class="card-body">
          <div class="alert alert-info">
            <strong>üìã Required Format:</strong>
            <ul class="mb-0 mt-2">
              <li>Each keyword must have <strong>exactly 2 rows</strong> (for 2 pins)</li>
              <li>Both rows must have the same <code>keyword</code> value</li>
              <li>Each row should have different pin titles, descriptions, and overlays</li>
            </ul>
          </div>

          <div class="mb-3">
            <label for="xlsxFile" class="form-label">Select XLSX File</label>
            <input type="file" class="form-control" id="xlsxFile" accept=".xlsx">
            <div class="form-text">
              <strong>Required columns:</strong> keyword, pin_title, pin_description, overlay_text, board_name, interests, website_category
            </div>
          </div>

          <button type="button" id="analyzeBtn" class="btn btn-primary" disabled>
            <i class="bi bi-search"></i> Analyze File
          </button>
        </div>
      </div>
    </div>

    <div class="col-md-6">
      <div class="card">
        <div class="card-header bg-success text-white">
          <h5 class="mb-0"><i class="bi bi-info-circle"></i> How It Works</h5>
        </div>
        <div class="card-body">
          <h6>For each keyword, the app will:</h6>
          <ul>
            <li>‚úÖ Generate <strong>1 SEO blog post</strong></li>
            <li>‚úÖ Create <strong>2 Midjourney images</strong> (one for each pin)</li>
            <li>‚úÖ Store <strong>2 Pinterest variations</strong>:
              <ul>
                <li>Pin 1: Title, description, overlay from row 1</li>
                <li>Pin 2: Title, description, overlay from row 2</li>
              </ul>
            </li>
            <li>‚úÖ Use Pin 1's image as the blog's featured image</li>
            <li>‚úÖ Skip PinClicks analysis (data already provided)</li>
          </ul>

          <div class="alert alert-warning mt-3 mb-0">
            <strong>‚ö†Ô∏è WordPress Publishing:</strong> Only 1 blog post per keyword will be published, even though there are 2 Pinterest variations.
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Analysis Results Section -->
  <div class="row mt-4 d-none" id="analysisSection">
    <div class="col-12">
      <div class="card">
        <div class="card-header bg-info text-white">
          <h5 class="mb-0"><i class="bi bi-check-circle"></i> Step 2: Review Analysis</h5>
        </div>
        <div class="card-body">
          <div class="row mb-3">
            <div class="col-md-3">
              <div class="card text-center">
                <div class="card-body">
                  <h3 class="text-primary mb-0" id="statsKeywords">0</h3>
                  <small class="text-muted">Keywords</small>
                </div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="card text-center">
                <div class="card-body">
                  <h3 class="text-success mb-0" id="statsPins">0</h3>
                  <small class="text-muted">Total Pins</small>
                </div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="card text-center">
                <div class="card-body">
                  <h3 class="text-info mb-0" id="statsBlogs">0</h3>
                  <small class="text-muted">Blog Posts</small>
                </div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="card text-center">
                <div class="card-body">
                  <h3 class="text-warning mb-0" id="statsImages">0</h3>
                  <small class="text-muted">MJ Images</small>
                </div>
              </div>
            </div>
          </div>

          <!-- Keyword Preview Table -->
          <div class="table-responsive">
            <table class="table table-striped table-hover" id="keywordPreviewTable">
              <thead>
                <tr>
                  <th>Keyword</th>
                  <th>Pin 1 Title</th>
                  <th>Pin 2 Title</th>
                  <th>Category</th>
                  <th>Board</th>
                </tr>
              </thead>
              <tbody id="keywordPreviewBody">
                <!-- Populated by JavaScript -->
              </tbody>
            </table>
          </div>

          <div class="mt-3">
            <button type="button" id="uploadBtn" class="btn btn-success btn-lg">
              <i class="bi bi-cloud-upload"></i> Upload to Database
            </button>
            <button type="button" id="cancelBtn" class="btn btn-secondary btn-lg">
              <i class="bi bi-x-circle"></i> Cancel
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Status Messages -->
  <div class="row mt-4">
    <div class="col-12" id="statusMessage"></div>
  </div>

  <!-- Live Status Bar - Always visible once job starts -->
  <div class="row mt-4 d-none" id="liveStatusBar">
    <div class="col-12">
      <div class="card" id="statusBarCard">
        <div class="card-header d-flex justify-content-between align-items-center" id="statusBarHeader">
          <h5 class="mb-0">
            <span id="statusBarIcon"><i class="bi bi-gear-fill spin-icon"></i></span>
            <span id="statusBarTitle">Processing...</span>
          </h5>
          <span class="badge fs-6" id="statusBarBadge">Running</span>
        </div>
        <div class="card-body">
          <!-- Progress Bar -->
          <div class="mb-3">
            <div class="d-flex justify-content-between mb-2">
              <span><strong>Overall Progress:</strong></span>
              <span id="progressText">0 / 0 keywords</span>
            </div>
            <div class="progress" style="height: 25px;">
              <div id="overallProgressBar" class="progress-bar progress-bar-striped progress-bar-animated"
                   role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                0%
              </div>
            </div>
          </div>

          <!-- Detailed Status Info -->
          <div class="row mt-3" id="statusDetails">
            <div class="col-md-3">
              <div class="d-flex align-items-center gap-2 p-2 rounded" style="background: rgba(255,255,255,0.05);">
                <i class="bi bi-bullseye text-info fs-5"></i>
                <div>
                  <small class="text-muted d-block">Current Keyword</small>
                  <strong id="statusCurrentKeyword">-</strong>
                </div>
              </div>
            </div>
            <div class="col-md-2">
              <div class="d-flex align-items-center gap-2 p-2 rounded" style="background: rgba(255,255,255,0.05);">
                <i class="bi bi-activity text-warning fs-5"></i>
                <div>
                  <small class="text-muted d-block">Current Step</small>
                  <strong id="statusCurrentStep">-</strong>
                </div>
              </div>
            </div>
            <div class="col-md-2">
              <div class="d-flex align-items-center gap-2 p-2 rounded" style="background: rgba(255,255,255,0.05);">
                <i class="bi bi-check-circle text-success fs-5"></i>
                <div>
                  <small class="text-muted d-block">Completed</small>
                  <strong id="statusCompleted">0</strong>
                </div>
              </div>
            </div>
            <div class="col-md-2">
              <div class="d-flex align-items-center gap-2 p-2 rounded" style="background: rgba(255,255,255,0.05);">
                <i class="bi bi-x-circle text-danger fs-5"></i>
                <div>
                  <small class="text-muted d-block">Failed</small>
                  <strong id="statusFailed">0</strong>
                </div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="d-flex align-items-center gap-2 p-2 rounded" style="background: rgba(255,255,255,0.05);">
                <i class="bi bi-clock-history text-secondary fs-5"></i>
                <div>
                  <small class="text-muted d-block">Elapsed Time</small>
                  <strong id="statusElapsedTime">00:00</strong>
                </div>
              </div>
            </div>
          </div>

          <!-- Per-keyword progress list -->
          <div class="mt-3">
            <small class="text-muted"><strong>Keyword Details:</strong></small>
            <div id="keywordProgressList" class="mt-2" style="max-height: 200px; overflow-y: auto;"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <style>
    .spin-icon { animation: spin 1.5s linear infinite; display: inline-block; }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    .kw-progress-item { display: flex; align-items: center; gap: 8px; padding: 4px 8px; border-radius: 4px; margin-bottom: 4px; font-size: 0.9em; }
    .kw-progress-item.status-processed { background: rgba(25, 135, 84, 0.12); }
    .kw-progress-item.status-processing { background: rgba(13, 110, 253, 0.12); }
    .kw-progress-item.status-pending { background: rgba(108, 117, 125, 0.08); }
    .kw-progress-item.status-failed { background: rgba(220, 53, 69, 0.12); }
  </style>

  <!-- Keywords List Section -->
  <div class="row mt-4">
    <div class="col-12">
      <div class="card">
        <div class="card-header">
          <h5 class="mb-0"><i class="bi bi-list-ul"></i> Uploaded Keywords</h5>
        </div>
        <div class="card-body">
          <!-- Job Control Buttons - Always visible -->
          <div class="mb-3 d-flex align-items-center gap-2">
            <button type="button" class="btn btn-warning" id="pauseProcessingBtn" disabled>
              <i class="bi bi-pause-fill me-1"></i>Pause
            </button>
            <button type="button" class="btn btn-success" id="resumeProcessingBtn" disabled>
              <i class="bi bi-play-fill me-1"></i>Resume
            </button>
            <button type="button" class="btn btn-danger" id="abandonProcessingBtn" disabled>
              <i class="bi bi-x-circle me-1"></i>Abandon
            </button>
          </div>

          <hr>

          <!-- Action Buttons at Top - Same as Keyword Manager -->
          <div class="mb-3">
            <button type="button" id="processSelectedBtn" class="btn btn-primary" disabled onclick="window.processKeywordsNow()">
              <i class="bi bi-play-circle"></i> Process Selected (<span id="selectedCount">0</span>)
            </button>
            <button type="button" id="deleteSelectedBtn" class="btn btn-danger" disabled>
              <i class="bi bi-trash"></i> Delete Selected (<span id="selectedCountDelete">0</span>)
            </button>
            <button type="button" id="refreshListBtn" class="btn btn-secondary">
              <i class="bi bi-arrow-clockwise"></i> Refresh
            </button>
          </div>

          <!-- Keywords Table -->
          <div class="table-responsive">
            <table class="table table-striped">
              <thead>
                <tr>
                  <th><input type="checkbox" id="selectAllKeywords"></th>
                  <th>Keyword</th>
                  <th>Pins</th>
                  <th>Status</th>
                  <th>Category</th>
                  <th>Added</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody id="keywordsListBody">
                <!-- Populated by JavaScript -->
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script>
  // ===== DEBUG: SCRIPT LOADED =====
  console.log('üî¥üî¥üî¥ GPT-XLSX SCRIPT VERSION 3 LOADED üî¥üî¥üî¥');

  let parsedData = null;

  // ========================================================================
  // GLOBAL PROCESS FUNCTION - Uses SAME endpoint as normal Keyword Manager
  // ========================================================================
  window.processKeywordsNow = async function() {
    const checkboxes = document.querySelectorAll('.keyword-checkbox:checked');
    const keywordIds = Array.from(checkboxes).map(cb => cb.value);

    if (keywordIds.length === 0) {
      showStatus('error', 'Please select keywords to process');
      return;
    }

    if (!confirm(`Process ${keywordIds.length} keyword(s)? This will generate blog posts and Midjourney images.`)) {
      return;
    }

    const btn = document.getElementById('processSelectedBtn');
    const originalHtml = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Processing...';

    try {
      // Use the SAME endpoint as normal Keyword Manager, with async mode for real-time tracking
      const response = await fetch('/api/keywords/process-selected', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache'
        },
        body: JSON.stringify({
          keywordIds: keywordIds,
          contentOption: 'all',  // Generate all content (blog + images)
          async: true  // Respond immediately, process in background
        })
      });

      const result = await response.json();

      if (result.success) {
        showStatus('success', result.message || 'Processing started');
        // Start monitoring progress
        processWasStarted = true;
        showProcessingProgress(keywordIds);
        startStatusPolling(keywordIds, originalHtml);
      } else {
        showStatus('error', result.message || 'Processing failed');
        btn.disabled = false;
        btn.innerHTML = originalHtml;
      }

    } catch (error) {
      console.error('Process error:', error);
      showStatus('error', 'Error: ' + error.message);
      btn.disabled = false;
      btn.innerHTML = originalHtml;
    }
  };
  // ========================================================================

  // Enable analyze button when file selected
  document.getElementById('xlsxFile').addEventListener('change', function(e) {
    const analyzeBtn = document.getElementById('analyzeBtn');
    analyzeBtn.disabled = !e.target.files.length;
  });

  // Analyze XLSX file
  document.getElementById('analyzeBtn').addEventListener('click', function() {
    const fileInput = document.getElementById('xlsxFile');
    const file = fileInput.files[0];

    if (!file) {
      showStatus('error', 'Please select a file first.');
      return;
    }

    const reader = new FileReader();
    reader.onload = function(e) {
      try {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { type: 'array' });
        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
        const jsonData = XLSX.utils.sheet_to_json(worksheet, { defval: '' });

        // Validate required columns
        const requiredColumns = ['keyword', 'pin_title', 'pin_description', 'overlay_text', 'board_name', 'interests', 'website_category'];
        const missingColumns = requiredColumns.filter(col => !(col in jsonData[0]));

        if (missingColumns.length > 0) {
          showStatus('error', 'Missing required columns: ' + missingColumns.join(', '));
          return;
        }

        // Group by keyword
        const keywordGroups = {};
        jsonData.forEach(row => {
          const keyword = row.keyword;
          if (!keywordGroups[keyword]) {
            keywordGroups[keyword] = [];
          }
          keywordGroups[keyword].push(row);
        });

        // Validate each keyword has 1 or 2 pins (allow single pin keywords)
        const invalidKeywords = [];
        Object.entries(keywordGroups).forEach(([keyword, pins]) => {
          if (pins.length < 1 || pins.length > 2) {
            invalidKeywords.push(`${keyword} (${pins.length} pins)`);
          }
        });

        if (invalidKeywords.length > 0) {
          showStatus('error', 'Each keyword must have 1 or 2 rows. Invalid keywords: ' + invalidKeywords.join(', '));
          return;
        }

        // Validate data per keyword and build report
        const dataReport = [];
        let totalMissing = 0;
        const fields = ['keyword', 'pin_title', 'pin_description', 'overlay_text', 'board_name', 'interests', 'website_category'];

        Object.entries(keywordGroups).forEach(([keyword, pins]) => {
          const missing = [];
          pins.forEach((pin, i) => {
            fields.forEach(field => {
              if (!pin[field] || String(pin[field]).trim() === '') {
                missing.push(`Pin ${i + 1}: ${field}`);
              }
            });
          });
          if (missing.length > 0) totalMissing += missing.length;
          dataReport.push({ keyword, pinCount: pins.length, missing });
        });

        // Store parsed data
        parsedData = {
          keywordGroups: keywordGroups,
          totalKeywords: Object.keys(keywordGroups).length,
          totalPins: jsonData.length,
          totalBlogs: Object.keys(keywordGroups).length,
          totalImages: jsonData.length,
          dataReport: dataReport,
          totalMissing: totalMissing
        };

        // Display analysis
        displayAnalysis(parsedData);
        if (totalMissing > 0) {
          showStatus('error', `Analysis complete: ${parsedData.totalKeywords} keywords found, but ${totalMissing} missing field(s) detected. Check the report below.`);
        } else {
          showStatus('success', `Analysis complete! ${parsedData.totalKeywords} keywords - all data present.`);
        }

      } catch (error) {
        console.error('Error parsing XLSX:', error);
        showStatus('error', 'Failed to parse XLSX file: ' + error.message);
      }
    };

    reader.readAsArrayBuffer(file);
  });

  // Display analysis results
  function displayAnalysis(data) {
    document.getElementById('statsKeywords').textContent = data.totalKeywords;
    document.getElementById('statsPins').textContent = data.totalPins;
    document.getElementById('statsBlogs').textContent = data.totalBlogs;
    document.getElementById('statsImages').textContent = data.totalImages;

    const tbody = document.getElementById('keywordPreviewBody');
    tbody.innerHTML = '';

    Object.entries(data.keywordGroups).forEach(([keyword, pins]) => {
      const report = data.dataReport.find(r => r.keyword === keyword);
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td><strong>${keyword}</strong></td>
        <td>${pins[0] ? pins[0].pin_title : '-'}</td>
        <td>${pins[1] ? pins[1].pin_title : '-'}</td>
        <td>${pins[0] ? pins[0].website_category : '-'}</td>
        <td>${pins[0] ? pins[0].board_name : '-'}</td>
      `;
      // Highlight row if missing data
      if (report && report.missing.length > 0) {
        tr.style.backgroundColor = 'rgba(220, 53, 69, 0.15)';
      }
      tbody.appendChild(tr);
    });

    // Show data validation report
    let reportContainer = document.getElementById('dataValidationReport');
    if (!reportContainer) {
      reportContainer = document.createElement('div');
      reportContainer.id = 'dataValidationReport';
      reportContainer.className = 'mt-3';
      document.getElementById('analysisSection').querySelector('.card-body').appendChild(reportContainer);
    }

    if (data.totalMissing > 0) {
      const problemKeywords = data.dataReport.filter(r => r.missing.length > 0);
      let reportHtml = `
        <div class="alert alert-warning">
          <h6 class="mb-2"><i class="bi bi-exclamation-triangle me-2"></i>Data Report: ${problemKeywords.length} keyword(s) with missing fields</h6>
          <ul class="mb-0 small">
      `;
      problemKeywords.forEach(r => {
        reportHtml += `<li><strong>${r.keyword}</strong>: ${r.missing.join(', ')}</li>`;
      });
      reportHtml += `</ul></div>`;
      reportContainer.innerHTML = reportHtml;
    } else {
      reportContainer.innerHTML = `
        <div class="alert alert-success">
          <i class="bi bi-check-circle me-2"></i>
          <strong>All data complete!</strong> Every keyword has all required fields filled.
        </div>
      `;
    }

    document.getElementById('analysisSection').classList.remove('d-none');
  }

  // Upload to database
  document.getElementById('uploadBtn').addEventListener('click', async function() {
    if (!parsedData) {
      showStatus('error', 'No data to upload. Please analyze a file first.');
      return;
    }

    const uploadBtn = document.getElementById('uploadBtn');
    uploadBtn.disabled = true;
    uploadBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Uploading...';

    try {
      const response = await fetch('/api/gpt-xlsx/upload', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ keywordGroups: parsedData.keywordGroups })
      });

      const result = await response.json();

      if (result.success) {
        showStatus('success', `Successfully uploaded ${result.keywordsAdded} keywords!`);
        document.getElementById('xlsxFile').value = '';
        document.getElementById('analysisSection').classList.add('d-none');
        parsedData = null;
        loadKeywordsList();
      } else {
        throw new Error(result.message || 'Upload failed');
      }

    } catch (error) {
      console.error('Upload error:', error);
      showStatus('error', error.message);
    } finally {
      uploadBtn.disabled = false;
      uploadBtn.innerHTML = '<i class="bi bi-cloud-upload"></i> Upload to Database';
    }
  });

  // Cancel analysis
  document.getElementById('cancelBtn').addEventListener('click', function() {
    document.getElementById('xlsxFile').value = '';
    document.getElementById('analysisSection').classList.add('d-none');
    document.getElementById('analyzeBtn').disabled = true;
    parsedData = null;
  });

  // Load keywords list
  async function loadKeywordsList() {
    try {
      console.log('üì• Loading keywords list...');
      const response = await fetch('/api/gpt-xlsx/list');
      console.log('üì° Response status:', response.status, response.statusText);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const result = await response.json();
      console.log('üìä Keywords list response:', result);
      console.log('üìä result.success:', result.success);
      console.log('üìä result.keywords:', result.keywords);
      console.log('üìä result.keywords.length:', result.keywords ? result.keywords.length : 'undefined');

      const tbody = document.getElementById('keywordsListBody');
      tbody.innerHTML = '';

      if (result.success && result.keywords && result.keywords.length > 0) {
        console.log(`‚úÖ Found ${result.keywords.length} keywords - rendering rows...`);
        result.keywords.forEach((kw, index) => {
          console.log(`  ${index + 1}. ${kw.keyword} (status: ${kw.status}, pins: ${kw.pin_count})`);
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td><input type="checkbox" class="keyword-checkbox" value="${kw.id}"></td>
            <td><strong>${kw.keyword}</strong></td>
            <td>${kw.pin_count}</td>
            <td><span class="badge bg-${getStatusColor(kw.status)}">${kw.status}</span></td>
            <td>${kw.category || '-'}</td>
            <td>${new Date(kw.added_at).toLocaleString()}</td>
            <td>
              <button class="btn btn-sm btn-info" onclick="viewKeyword('${kw.id}')">
                <i class="bi bi-eye"></i>
              </button>
              <button class="btn btn-sm btn-danger" onclick="deleteKeyword('${kw.id}')">
                <i class="bi bi-trash"></i>
              </button>
            </td>
          `;
          tbody.appendChild(tr);
        });
        console.log('‚úÖ All rows rendered successfully');

        updateSelectedCount();
      } else {
        console.log('‚ö†Ô∏è No keywords found or result not successful');
        console.log('  result.success:', result.success);
        console.log('  result.keywords exists:', !!result.keywords);
        console.log('  result.keywords.length:', result.keywords ? result.keywords.length : 'N/A');
        tbody.innerHTML = '<tr><td colspan="7" class="text-center">No keywords uploaded yet.</td></tr>';
      }

    } catch (error) {
      console.error('‚ùå Error loading keywords:', error);
      const tbody = document.getElementById('keywordsListBody');
      tbody.innerHTML = `<tr><td colspan="7" class="text-center text-danger">Error: ${error.message}</td></tr>`;
    }
  }

  // Update selected count
  function updateSelectedCount() {
    const selected = document.querySelectorAll('.keyword-checkbox:checked').length;

    // Safely update count spans (they might not exist if button text was changed)
    const selectedCountSpan = document.getElementById('selectedCount');
    const selectedCountDeleteSpan = document.getElementById('selectedCountDelete');

    if (selectedCountSpan) {
      selectedCountSpan.textContent = selected;
    }
    if (selectedCountDeleteSpan) {
      selectedCountDeleteSpan.textContent = selected;
    }

    // Update button states
    const processBtn = document.getElementById('processSelectedBtn');
    const deleteBtn = document.getElementById('deleteSelectedBtn');

    if (processBtn && !processBtn.innerHTML.includes('Processing')) {
      processBtn.disabled = selected === 0;
    }
    if (deleteBtn && !deleteBtn.innerHTML.includes('Deleting')) {
      deleteBtn.disabled = selected === 0;
    }
  }

  // Checkbox event listeners
  document.addEventListener('change', function(e) {
    if (e.target.classList.contains('keyword-checkbox') || e.target.id === 'selectAllKeywords') {
      if (e.target.id === 'selectAllKeywords') {
        document.querySelectorAll('.keyword-checkbox').forEach(cb => {
          cb.checked = e.target.checked;
        });
      }
      updateSelectedCount();
    }
  });

  // Helper functions
  function getStatusColor(status) {
    const colors = {
      'pending': 'secondary',
      'processing': 'warning',
      'processed': 'success',
      'failed': 'danger'
    };
    return colors[status] || 'secondary';
  }

  function showStatus(type, message) {
    const statusDiv = document.getElementById('statusMessage');
    const alertClass = type === 'error' ? 'alert-danger' : 'alert-success';
    statusDiv.innerHTML = `<div class="alert ${alertClass}">${message}</div>`;

    setTimeout(() => {
      statusDiv.innerHTML = '';
    }, 5000);
  }

  // OLD EVENT LISTENER - DISABLED (using onclick handler in button HTML instead)
  // The onclick="window.processKeywordsNow()" on the button handles this now
  /*
  document.getElementById('processSelectedBtn').addEventListener('click', async function() {
    // ... OLD CODE DISABLED ...
  });
  */

  // Set job control button states: 'idle', 'processing', 'paused'
  function setJobControlState(state) {
    const pauseBtn = document.getElementById('pauseProcessingBtn');
    const resumeBtn = document.getElementById('resumeProcessingBtn');
    const abandonBtn = document.getElementById('abandonProcessingBtn');

    if (state === 'processing') {
      pauseBtn.disabled = false;
      resumeBtn.disabled = true;
      abandonBtn.disabled = false;
    } else if (state === 'paused') {
      pauseBtn.disabled = true;
      resumeBtn.disabled = false;
      abandonBtn.disabled = false;
    } else {
      // idle - all disabled
      pauseBtn.disabled = true;
      resumeBtn.disabled = true;
      abandonBtn.disabled = true;
    }
  }

  // ============================================================
  // LIVE STATUS BAR FUNCTIONS
  // ============================================================
  let jobStartTime = null;
  let elapsedTimerInterval = null;
  let lastKeywordResults = [];

  // Show the status bar and start timer
  function showProcessingProgress(keywordIds) {
    const bar = document.getElementById('liveStatusBar');
    bar.classList.remove('d-none');

    // Set buttons to processing state
    setJobControlState('processing');

    // Start elapsed timer
    jobStartTime = Date.now();
    startElapsedTimer();

    // Initialize progress
    updateOverallProgress(0, keywordIds.length);
    setStatusBarMode('processing');

    // Build initial keyword list
    const listEl = document.getElementById('keywordProgressList');
    listEl.innerHTML = '';
  }

  // Hide the status bar
  function hideProcessingProgress() {
    const bar = document.getElementById('liveStatusBar');
    bar.classList.add('d-none');
    stopElapsedTimer();
  }

  // Set the status bar visual mode: processing, paused, completed, failed, idle
  function setStatusBarMode(mode) {
    const header = document.getElementById('statusBarHeader');
    const badge = document.getElementById('statusBarBadge');
    const icon = document.getElementById('statusBarIcon');
    const title = document.getElementById('statusBarTitle');
    const progressBar = document.getElementById('overallProgressBar');

    // Reset
    header.className = 'card-header d-flex justify-content-between align-items-center';
    badge.className = 'badge fs-6';

    if (mode === 'processing') {
      header.classList.add('bg-primary', 'text-white');
      badge.classList.add('bg-light', 'text-primary');
      badge.textContent = 'Running';
      icon.innerHTML = '<i class="bi bi-gear-fill spin-icon"></i>';
      title.textContent = 'Processing...';
      progressBar.classList.add('progress-bar-animated');
      progressBar.classList.remove('bg-warning', 'bg-success', 'bg-danger');
      progressBar.classList.add('bg-primary');
    } else if (mode === 'paused') {
      header.classList.add('bg-warning', 'text-dark');
      badge.classList.add('bg-dark', 'text-warning');
      badge.textContent = 'Paused';
      icon.innerHTML = '<i class="bi bi-pause-circle-fill"></i>';
      title.textContent = 'Job Paused';
      progressBar.classList.remove('progress-bar-animated', 'bg-primary', 'bg-success', 'bg-danger');
      progressBar.classList.add('bg-warning');
    } else if (mode === 'completed') {
      header.classList.add('bg-success', 'text-white');
      badge.classList.add('bg-light', 'text-success');
      badge.textContent = 'Completed';
      icon.innerHTML = '<i class="bi bi-check-circle-fill"></i>';
      title.textContent = 'All Done!';
      progressBar.classList.remove('progress-bar-animated', 'bg-primary', 'bg-warning', 'bg-danger');
      progressBar.classList.add('bg-success');
      stopElapsedTimer();
    } else if (mode === 'failed') {
      header.classList.add('bg-danger', 'text-white');
      badge.classList.add('bg-light', 'text-danger');
      badge.textContent = 'Failed';
      icon.innerHTML = '<i class="bi bi-exclamation-triangle-fill"></i>';
      title.textContent = 'Processing Failed';
      progressBar.classList.remove('progress-bar-animated', 'bg-primary', 'bg-warning', 'bg-success');
      progressBar.classList.add('bg-danger');
      stopElapsedTimer();
    }
  }

  // Update overall progress bar
  function updateOverallProgress(completed, total) {
    const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;
    const progressBar = document.getElementById('overallProgressBar');
    const progressText = document.getElementById('progressText');

    progressBar.style.width = percentage + '%';
    progressBar.textContent = percentage + '%';
    progressBar.setAttribute('aria-valuenow', percentage);
    progressText.textContent = `${completed} / ${total} keywords`;
  }

  // Update the detailed status info from polling results
  function updateStatusDetails(keywords) {
    lastKeywordResults = keywords;

    const completed = keywords.filter(k => k.status === 'processed').length;
    const failed = keywords.filter(k => k.status === 'failed').length;
    const processing = keywords.find(k => k.status === 'processing');

    document.getElementById('statusCompleted').textContent = completed;
    document.getElementById('statusFailed').textContent = failed;

    if (processing) {
      document.getElementById('statusCurrentKeyword').textContent = processing.keyword;

      // Determine current step
      let stepText = 'Starting...';
      if (!processing.hasBlog) {
        stepText = 'Generating Blog';
      } else if (!processing.hasImage) {
        stepText = 'Creating Images';
      } else {
        stepText = 'Finalizing';
      }
      document.getElementById('statusCurrentStep').textContent = stepText;
    } else if (completed + failed === keywords.length) {
      document.getElementById('statusCurrentKeyword').textContent = '-';
      document.getElementById('statusCurrentStep').textContent = 'Done';
    }

    // Build per-keyword progress list
    const listEl = document.getElementById('keywordProgressList');
    listEl.innerHTML = '';
    keywords.forEach((kw, idx) => {
      const item = document.createElement('div');
      item.className = `kw-progress-item status-${kw.status}`;

      let icon, statusLabel, stepDetail = '';
      if (kw.status === 'processed') {
        icon = '<i class="bi bi-check-circle-fill text-success"></i>';
        statusLabel = 'Done';
      } else if (kw.status === 'failed') {
        icon = '<i class="bi bi-x-circle-fill text-danger"></i>';
        statusLabel = 'Failed';
      } else if (kw.status === 'processing') {
        icon = '<span class="spinner-border spinner-border-sm text-primary"></span>';
        if (!kw.hasBlog) {
          stepDetail = ' ‚Äî Generating blog post...';
        } else if (!kw.hasImage) {
          stepDetail = ' ‚Äî Creating Midjourney images...';
        } else {
          stepDetail = ' ‚Äî Finalizing...';
        }
        statusLabel = 'Processing';
      } else {
        icon = '<i class="bi bi-hourglass text-muted"></i>';
        statusLabel = 'Waiting';
      }

      item.innerHTML = `
        ${icon}
        <span class="fw-bold">${idx + 1}. ${kw.keyword}</span>
        <span class="badge bg-${kw.status === 'processed' ? 'success' : kw.status === 'failed' ? 'danger' : kw.status === 'processing' ? 'primary' : 'secondary'} ms-auto">${statusLabel}</span>
        <small class="text-muted">${stepDetail}</small>
      `;
      listEl.appendChild(item);
    });
  }

  // Elapsed time ticker
  function startElapsedTimer() {
    stopElapsedTimer();
    elapsedTimerInterval = setInterval(() => {
      if (!jobStartTime) return;
      const elapsed = Math.floor((Date.now() - jobStartTime) / 1000);
      const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
      const secs = (elapsed % 60).toString().padStart(2, '0');
      document.getElementById('statusElapsedTime').textContent = `${mins}:${secs}`;
    }, 1000);
  }

  function stopElapsedTimer() {
    if (elapsedTimerInterval) {
      clearInterval(elapsedTimerInterval);
      elapsedTimerInterval = null;
    }
  }

  // Legacy wrappers for compatibility
  function updateCurrentKeyword(keywordName) {
    document.getElementById('statusCurrentKeyword').textContent = keywordName;
  }
  function updateWorkflowStep() {} // no-op, replaced by updateStatusDetails
  function resetWorkflowSteps() {} // no-op

  // Poll for status updates during processing
  let pollingInterval = null;
  let processedCount = 0;
  let totalCount = 0;
  let processWasStarted = false; // Safeguard flag

  function startStatusPolling(keywordIds, originalHtml) {
    // SAFEGUARD: Only allow polling if process was actually started
    if (!processWasStarted) {
      console.log('‚ùå BLOCKED: startStatusPolling called but processWasStarted is false!');
      alert('ERROR: Polling attempted without process being started!');
      return;
    }

    console.log('üìä Starting status polling for keywords:', keywordIds);

    processedCount = 0;
    totalCount = keywordIds.length;

    // Refresh list immediately
    loadKeywordsList();

    // Set up polling every 3 seconds to check progress
    pollingInterval = setInterval(async () => {
      try {
        // Check status of each keyword
        const response = await fetch('/api/gpt-xlsx/progress', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ keywordIds })
        });

        const result = await response.json();

        // Check if backend says to stop polling
        if (result.shouldStopPolling) {
          console.log('üõë Backend says to stop polling. allPending:', result.allPending, 'allDone:', result.allDone);
          clearInterval(pollingInterval);
          pollingInterval = null;
          processWasStarted = false;

          setJobControlState('idle');

          if (result.allPending) {
            showStatus('error', 'Processing did not start. Please try again.');
            hideProcessingProgress();
            const processBtn = document.getElementById('processSelectedBtn');
            processBtn.disabled = false;
            processBtn.innerHTML = '<i class="bi bi-play-circle"></i> Process Selected Keywords (<span id="selectedCount">0</span>)';
          } else if (result.allDone) {
            showStatus('success', 'All keywords processed!');
            if (result.keywords) updateStatusDetails(result.keywords);
            const failed = result.keywords ? result.keywords.filter(k => k.status === 'failed').length : 0;
            setStatusBarMode(failed === result.keywords.length ? 'failed' : 'completed');
            updateOverallProgress(totalCount, totalCount);
            const processBtn = document.getElementById('processSelectedBtn');
            processBtn.disabled = false;
            processBtn.innerHTML = '<i class="bi bi-play-circle"></i> Process Selected Keywords (<span id="selectedCount">0</span>)';
          }
          loadKeywordsList();
          return;
        }

        if (result.success && result.keywords) {
          const completed = result.keywords.filter(k => k.status === 'processed' || k.status === 'failed').length;
          const failed = result.keywords.filter(k => k.status === 'failed').length;

          updateOverallProgress(completed, totalCount);
          updateStatusDetails(result.keywords);

          // If all keywords are done, stop polling
          if (completed === totalCount) {
            clearInterval(pollingInterval);
            pollingInterval = null;

            setJobControlState('idle');
            setStatusBarMode(failed === totalCount ? 'failed' : 'completed');

            // Re-enable process button
            const processBtn = document.getElementById('processSelectedBtn');
            processBtn.disabled = false;
            processBtn.innerHTML = originalHtml;

            // Final refresh
            loadKeywordsList();
          }
        }
      } catch (error) {
        console.error('Error checking progress:', error);
      }
    }, 3000);

    // Stop polling after 10 minutes (safety timeout)
    setTimeout(() => {
      if (pollingInterval) {
        clearInterval(pollingInterval);
        pollingInterval = null;
        console.log('‚è±Ô∏è Stopped status polling after 10 minutes');

        setJobControlState('idle');
        hideProcessingProgress();

        // Re-enable process button
        const processBtn = document.getElementById('processSelectedBtn');
        processBtn.disabled = false;
        processBtn.innerHTML = originalHtml;
      }
    }, 600000); // 10 minutes
  }

  // Pause processing
  let isPaused = false;

  document.getElementById('pauseProcessingBtn').addEventListener('click', async function() {
    try {
      const resp = await fetch('/api/keywords/pause', { method: 'POST', headers: { 'Content-Type': 'application/json' } });
      const result = await resp.json();
      if (result.success) {
        isPaused = true;
        setJobControlState('paused');
        setStatusBarMode('paused');
        stopElapsedTimer();

        // Stop polling - the server will stop after current keyword
        if (pollingInterval) {
          clearInterval(pollingInterval);
          pollingInterval = null;
        }

        showStatus('success', 'Processing paused. Current keyword will finish, then processing stops.');
      }
    } catch (error) {
      showStatus('error', 'Failed to pause: ' + error.message);
    }
  });

  document.getElementById('resumeProcessingBtn').addEventListener('click', async function() {
    try {
      // Clear pause flag on server
      await fetch('/api/keywords/resume', { method: 'POST', headers: { 'Content-Type': 'application/json' } });

      // Find all pending AND stuck processing keywords (stuck = server restarted mid-process)
      const listResp = await fetch('/api/gpt-xlsx/list');
      const listResult = await listResp.json();

      if (listResult.success && listResult.keywords) {
        const resumableIds = listResult.keywords
          .filter(k => k.status === 'pending' || k.status === 'processing')
          .map(k => k.id);

        if (resumableIds.length === 0) {
          showStatus('success', 'No pending keywords to resume.');
          setJobControlState('idle');
          hideProcessingProgress();
          return;
        }

        isPaused = false;

        setStatusBarMode('processing');
        startElapsedTimer();

        showStatus('success', `Resuming processing of ${resumableIds.length} remaining keywords...`);

        // Re-trigger processing in async mode
        const response = await fetch('/api/keywords/process-selected', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ keywordIds: resumableIds, contentOption: 'all', async: true })
        });

        const result = await response.json();
        if (result.success) {
          processWasStarted = true;
          showProcessingProgress(resumableIds);
          startStatusPolling(resumableIds, '<i class="bi bi-play-circle"></i> Process Selected (<span id="selectedCount">0</span>)');
        }
      }
    } catch (error) {
      showStatus('error', 'Failed to resume: ' + error.message);
    }
  });

  // Abandon processing
  document.getElementById('abandonProcessingBtn').addEventListener('click', async function() {
    if (!confirm('Are you sure you want to abandon all processing? All pending/processing keywords will be marked as failed.')) {
      return;
    }

    const abandonBtn = document.getElementById('abandonProcessingBtn');
    try {
      abandonBtn.disabled = true;
      abandonBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Abandoning...';

      // 1. Pause processing to stop further keywords from being picked up
      await fetch('/api/keywords/pause', { method: 'POST', headers: { 'Content-Type': 'application/json' } });

      // 2. Get all keywords and find pending/processing ones
      const listResp = await fetch('/api/gpt-xlsx/list');
      const listResult = await listResp.json();

      if (listResult.success && listResult.keywords) {
        const activeIds = listResult.keywords
          .filter(k => k.status === 'pending' || k.status === 'processing')
          .map(k => k.id);

        // 3. Cancel all active keywords
        if (activeIds.length > 0) {
          await fetch('/api/keywords/cancel', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ keywordIds: activeIds })
          });
        }
      }

      // 4. Stop polling
      if (pollingInterval) {
        clearInterval(pollingInterval);
        pollingInterval = null;
      }
      processWasStarted = false;
      isPaused = false;

      // 5. Reset UI - buttons back to idle
      setJobControlState('idle');
      setStatusBarMode('failed');
      stopElapsedTimer();
      loadKeywordsList();

      // 6. Re-enable process button
      const processBtn = document.getElementById('processSelectedBtn');
      if (processBtn) {
        processBtn.disabled = false;
        processBtn.innerHTML = '<i class="bi bi-play-circle"></i> Process Selected (<span id="selectedCount">0</span>)';
      }

      showStatus('error', 'Processing abandoned. All pending keywords marked as failed.');

    } catch (error) {
      console.error('Abandon error:', error);
      showStatus('error', 'Failed to abandon: ' + error.message);
    } finally {
      abandonBtn.innerHTML = '<i class="bi bi-x-circle me-1"></i>Abandon';
      // Keep buttons in idle state after abandon
      setJobControlState('idle');
    }
  });

  // Delete selected keywords
  document.getElementById('deleteSelectedBtn').addEventListener('click', async function() {
    const checkboxes = document.querySelectorAll('.keyword-checkbox:checked');
    const keywordIds = Array.from(checkboxes).map(cb => cb.value);

    if (keywordIds.length === 0) {
      showStatus('error', 'Please select keywords to delete');
      return;
    }

    if (!confirm(`Are you sure you want to delete ${keywordIds.length} keyword(s)? This will also delete all associated data (recipes, Pinterest variations, images).`)) {
      return;
    }

    const deleteBtn = document.getElementById('deleteSelectedBtn');
    deleteBtn.disabled = true;
    deleteBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Deleting...';

    try {
      const response = await fetch('/api/gpt-xlsx/delete-bulk', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ keywordIds })
      });

      const result = await response.json();

      if (result.success) {
        showStatus('success', `Successfully deleted ${keywordIds.length} keyword(s)`);
        loadKeywordsList();
        document.getElementById('selectAllKeywords').checked = false;
      } else {
        throw new Error(result.message || 'Delete failed');
      }

    } catch (error) {
      console.error('Delete error:', error);
      showStatus('error', error.message);
    } finally {
      deleteBtn.disabled = false;
      deleteBtn.innerHTML = '<i class="bi bi-trash"></i> Delete Selected (<span id="selectedCountDelete">0</span>)';
    }
  });

  // Check if there are unfinished keywords on page load (e.g. after PC restart)
  async function checkForUnfinishedWork() {
    try {
      const response = await fetch('/api/gpt-xlsx/list');
      const result = await response.json();
      if (result.success && result.keywords) {
        const allKeywords = result.keywords;
        const unfinished = allKeywords.filter(k => k.status === 'pending' || k.status === 'processing');
        const completed = allKeywords.filter(k => k.status === 'processed');
        const failed = allKeywords.filter(k => k.status === 'failed');

        if (unfinished.length > 0) {
          // There are keywords waiting ‚Äî show status bar in paused state
          setJobControlState('paused');

          // Show status bar with current state
          const bar = document.getElementById('liveStatusBar');
          bar.classList.remove('d-none');
          setStatusBarMode('paused');

          // Show progress so far
          const total = allKeywords.length;
          const done = completed.length + failed.length;
          updateOverallProgress(done, total);

          document.getElementById('statusCompleted').textContent = completed.length;
          document.getElementById('statusFailed').textContent = failed.length;
          document.getElementById('statusCurrentKeyword').textContent = '-';
          document.getElementById('statusCurrentStep').textContent = 'Paused';
          document.getElementById('statusElapsedTime').textContent = '--:--';

          // Build keyword detail list
          const listEl = document.getElementById('keywordProgressList');
          listEl.innerHTML = '';
          allKeywords.forEach((kw, idx) => {
            const item = document.createElement('div');
            item.className = `kw-progress-item status-${kw.status}`;
            let icon, statusLabel;
            if (kw.status === 'processed') {
              icon = '<i class="bi bi-check-circle-fill text-success"></i>';
              statusLabel = 'Done';
            } else if (kw.status === 'failed') {
              icon = '<i class="bi bi-x-circle-fill text-danger"></i>';
              statusLabel = 'Failed';
            } else {
              icon = '<i class="bi bi-hourglass text-muted"></i>';
              statusLabel = 'Waiting';
            }
            item.innerHTML = `
              ${icon}
              <span class="fw-bold">${idx + 1}. ${kw.keyword}</span>
              <span class="badge bg-${kw.status === 'processed' ? 'success' : kw.status === 'failed' ? 'danger' : 'secondary'} ms-auto">${statusLabel}</span>
            `;
            listEl.appendChild(item);
          });

          showStatus('success', `${unfinished.length} keyword(s) are waiting to be processed. Click Resume to continue.`);
        }
      }
    } catch (error) {
      console.error('Error checking for unfinished work:', error);
    }
  }

  // Load keywords on page load
  loadKeywordsList();
  checkForUnfinishedWork();

  // Refresh button
  document.getElementById('refreshListBtn').addEventListener('click', loadKeywordsList);
</script>
