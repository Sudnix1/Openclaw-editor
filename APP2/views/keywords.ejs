<!-- Keywords management page -->
<div class="row mb-4">
  <!-- Stats Section -->
  <div class="col-md-12">
    <div class="card">
      <div class="card-header">
        <h5 class="card-title">Keywords Statistics</h5>
      </div>
      <div class="card-body">
        <div class="row">
          <div class="col-md-3">
            <div class="stats-box text-center p-3 border rounded">
              <h3><%= stats.total %></h3>
              <p class="mb-0">Total Keywords</p>
            </div>
          </div>
          <div class="col-md-3">
            <div class="stats-box text-center p-3 border rounded bg-warning bg-opacity-10">
              <h3><%= stats.pending %></h3>
              <p class="mb-0">Pending Keywords</p>
            </div>
          </div>
          <div class="col-md-3">
            <div class="stats-box text-center p-3 border rounded bg-success bg-opacity-10">
              <h3><%= stats.processed %></h3>
              <p class="mb-0">Processed Keywords</p>
            </div>
          </div>
          <div class="col-md-3">
            <div class="stats-box text-center p-3 border rounded bg-danger bg-opacity-10">
              <h3><%= stats.failed %></h3>
              <p class="mb-0">Failed Keywords</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Process Keywords Section -->
  <div class="card mt-4">
    <div class="card-header">
      <h5 class="card-title">Process Keywords</h5>
    </div>
    <div class="card-body">
      <form id="processKeywordsForm">
        <div class="mb-3">
          <label class="form-label">Content Generation Options</label>
          <div class="form-check">
            <input class="form-check-input" type="radio" name="contentOption" id="optionFacebook" value="facebook">
            <label class="form-check-label" for="optionFacebook">
              Facebook & Midjourney
            </label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="radio" name="contentOption" id="optionPinterest" value="pinterest">
            <label class="form-check-label" for="optionPinterest">
              Pinterest & Blog
            </label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="radio" name="contentOption" id="optionAll" value="all" checked>
            <label class="form-check-label" for="optionAll">
              All Content
            </label>
          </div>
        </div>

        
        <button type="button" id="processSelectedBtn" class="btn btn-success" disabled>
          Process Selected Keywords (<span id="selectedCount">0</span>)
        </button>
        <button type="button" id="processNextBtn" class="btn btn-primary">
          Process Next Pending Keywords
        </button>
      </form>
    </div>
  </div>
</div>

<div class="row">
  <!-- Add Keywords Section -->
  <div class="col-md-5">
    <div class="card">
      <div class="card-header">
        <h5 class="card-title">Add Keywords</h5>
      </div>
      <div class="card-body">
       <form id="addKeywordsForm" method="POST">
          <ul class="nav nav-tabs mb-3" id="inputTabs" role="tablist">
            <li class="nav-item" role="presentation">
              <button class="nav-link active" id="manual-tab" data-bs-toggle="tab" data-bs-target="#manual" type="button" role="tab" aria-controls="manual" aria-selected="true">Manual Entry</button>
            </li>
            <li class="nav-item" role="presentation">
              <button class="nav-link" id="excel-tab" data-bs-toggle="tab" data-bs-target="#excel" type="button" role="tab" aria-controls="excel" aria-selected="false">Excel Upload</button>
            </li>
            <li class="nav-item" role="presentation">
              <button class="nav-link" id="pinclicks-tab" data-bs-toggle="tab" data-bs-target="#pinclicks" type="button" role="tab" aria-controls="pinclicks" aria-selected="false">PinClicks Analysis</button>
            </li>
          </ul>
          
          <div class="tab-content" id="inputTabsContent">
            <!-- Manual Entry Tab -->
            <div class="tab-pane fade show active" id="manual" role="tabpanel" aria-labelledby="manual-tab">
  <div class="mb-3">
    <label for="keywords" class="form-label">Complete Recipes (One per entry, separated by "---")</label>
    <textarea class="form-control" id="keywords" name="keywords" rows="15" placeholder="Enter complete recipes separated by --- for example:
The Best Moist Chocolate Cake Recipe
Ingredients:
1 cup cake flour
1/3 cup cocoa powder
1 cup sugar
1/2 tsp salt
1 tsp baking powder
1 tsp baking soda
2 large eggs
1/2 cup full cream milk
1/4 cup vegetable oil
1 tsp vanilla extract
1/2 to 1 tsp coffee
1/2 cup boiling water
1 tbsp white vinegar
Instructions:
1. Preheat your oven to 175¬∞C (350¬∞F). Grease and flour a cake pan.
2. In a mixing bowl, sift together cake flour, cocoa powder, sugar, salt, baking powder, and baking soda.
3. Add eggs, milk, oil, and vanilla extract. Mix until well combined.
4. Dissolve coffee in boiling water and add to batter.
5. Stir in white vinegar and mix until fully incorporated.
6. Pour into prepared pan and bake for 40 minutes or until done.
---
Easy Chicken Alfredo Pasta
Ingredients:
2 chicken breasts
1 lb fettuccine pasta
1 cup heavy cream
1/2 cup parmesan cheese
2 cloves garlic
2 tbsp butter
Salt and pepper to taste
Instructions:
1. Cook pasta according to package directions.
2. Season and cook chicken until golden brown.
3. Make alfredo sauce with cream, garlic, and parmesan.
4. Combine everything and serve hot."></textarea>
  </div>
  
  <div class="mb-3">
    <label for="imageUrl" class="form-label">Reference Image URL</label>
    <input type="url" class="form-control" id="imageUrl" name="imageUrl" placeholder="https://example.com/image.jpg">
    <div class="form-text">Add a reference image URL for Midjourney</div>
  </div>

  <div class="mb-3">
    <label for="pinterestBoard" class="form-label">Pinterest Board</label>
    <select class="form-select" id="pinterestBoard" name="pinterestBoard">
      <%
        const pinterestBoardsList = (promptConfig && promptConfig.pinterestBoards) ?
          promptConfig.pinterestBoards.split(',').map(b => b.trim()) :
          ['Breakfast', 'Lunch', 'Dinner', 'Dessert'];
        pinterestBoardsList.forEach(board => {
      %>
        <option value="<%= board %>" <%= board === 'Dinner' ? 'selected' : '' %>><%= board %></option>
      <% }); %>
    </select>
    <div class="form-text">Select the Pinterest board for this keyword</div>
  </div>
</div>

            <!-- Excel Upload Tab -->
            <div class="tab-pane fade" id="excel" role="tabpanel" aria-labelledby="excel-tab">
              <div class="mb-3">
                <label for="excelFile" class="form-label">Upload Excel File</label>
                <input type="file" class="form-control" id="excelFile" name="excelFile" accept=".xlsx, .xls, .csv">
                <div class="form-text">
                  Excel file should have columns with these headers:
                  <ul class="mt-2">
                    <li><strong>Keyword</strong> (required) - Recipe title OR complete recipe with ingredients and instructions</li>
                    <li><strong>Category</strong> (optional) - Recipe category</li>
                    <li><strong>ImageUrl</strong> (optional) - Reference image URL for Midjourney</li>
                    <li><strong>Interests</strong> (optional) - Target audience interests</li>
                  </ul>
                  <div class="alert alert-info mt-2">
                    <strong>üí° How it works:</strong>
                    <ul class="mb-0">
                      <li><strong>Simple keywords:</strong> "Chocolate Chip Cookies" ‚Üí AI will generate the full recipe</li>
                      <li><strong>Complete recipes:</strong> Full recipe with ingredients and instructions ‚Üí Stored as-is</li>
                    </ul>
                    The system automatically detects whether your Keyword column contains simple keywords or complete recipes!
                  </div>
                </div>
              </div>
              
              <div id="excelPreview" class="mb-3 d-none">
                <h6>Excel Preview</h6>
                <div class="table-responsive">
                  <table class="table table-sm table-bordered">
                    <thead id="excelPreviewHeader"></thead>
                    <tbody id="excelPreviewBody"></tbody>
                  </table>
                </div>
                <p class="text-muted"><small>Showing preview of first 5 rows</small></p>
              </div>
              
              <div class="mb-3">
                <label for="excelDefaultImageUrl" class="form-label">Default Image URL (for keywords without image)</label>
                <input type="url" class="form-control" id="excelDefaultImageUrl" name="excelDefaultImageUrl" placeholder="https://example.com/image.jpg">
              </div>

              <div class="mb-3">
                <label for="excelPinterestBoard" class="form-label">Pinterest Board</label>
                <select class="form-select" id="excelPinterestBoard" name="excelPinterestBoard">
                  <%
                    const pinterestBoardsListExcel = (promptConfig && promptConfig.pinterestBoards) ?
                      promptConfig.pinterestBoards.split(',').map(b => b.trim()) :
                      ['Breakfast', 'Lunch', 'Dinner', 'Dessert'];
                    pinterestBoardsListExcel.forEach(board => {
                  %>
                    <option value="<%= board %>" <%= board === 'Dinner' ? 'selected' : '' %>><%= board %></option>
                  <% }); %>
                </select>
                <div class="form-text">Select the Pinterest board for these keywords</div>
              </div>
            </div>
            
            <!-- PinClicks Analysis Tab - Enhanced with Excel Upload -->
            <div class="tab-pane fade" id="pinclicks" role="tabpanel" aria-labelledby="pinclicks-tab">
              <div class="alert alert-info">
                <strong>PinClicks Analysis</strong>
                <p>Upload a CSV or Excel file with PinClicks data. The system will analyze the file to extract relevant interests and can process multiple keywords at once.</p>
              </div>
              
              <!-- File Upload Tabs -->
              <ul class="nav nav-pills mb-3" id="pinclicksUploadTabs" role="tablist">
                <li class="nav-item" role="presentation">
                  <button class="nav-link active" id="pinclicks-csv-tab" data-bs-toggle="pill" data-bs-target="#pinclicks-csv" type="button" role="tab">CSV Upload</button>
                </li>
                <li class="nav-item" role="presentation">
                  <button class="nav-link" id="pinclicks-excel-tab" data-bs-toggle="pill" data-bs-target="#pinclicks-excel" type="button" role="tab">Excel Upload</button>
                </li>
              </ul>
              
              <div class="tab-content" id="pinclicksUploadTabsContent">
                <!-- CSV Upload Tab -->
                <div class="tab-pane fade show active" id="pinclicks-csv" role="tabpanel">
                  <div class="mb-3">
                    <label for="pinclicksFile" class="form-label">Upload PinClicks CSV File</label>
                    <input type="file" class="form-control" id="pinclicksFile" name="pinclicksFile" accept=".csv">
                    <div class="form-text">CSV file should have keywords in the first column and occurrence counts in the second column.</div>
                  </div>
                  
                  <div class="mb-3">
                    <label for="pinclicksRecipeInput" class="form-label">Recipe Input</label>
                    <textarea class="form-control" id="pinclicksRecipeInput" name="pinclicksRecipeInput" rows="8" placeholder="Enter either:
1. Simple keyword: Chocolate Chip Cookies
2. Complete recipe with ingredients and instructions:
Easy Chocolate Chip Cookies
Ingredients:
- 2 cups flour
- 1 cup sugar
- 1/2 cup butter
- 2 eggs
- 1 tsp vanilla
Instructions:
1. Preheat oven to 350¬∞F
2. Mix dry ingredients
3. Add wet ingredients
4. Bake for 12 minutes"></textarea>
                    <div class="form-text">
                      <strong>üí° How it works:</strong>
                      <ul class="mb-0">
                        <li><strong>Simple keywords:</strong> "Chocolate Chip Cookies" ‚Üí AI will generate the full recipe</li>
                        <li><strong>Complete recipes:</strong> Full recipe with ingredients and instructions ‚Üí Stored as-is</li>
                      </ul>
                      The system automatically detects whether you entered a simple keyword or complete recipe!
                    </div>
                  </div>
                </div>
                
                <!-- Excel Upload Tab -->
                <div class="tab-pane fade" id="pinclicks-excel" role="tabpanel">
                  <div class="mb-3">
                    <label for="pinclicksExcelFile" class="form-label">Upload PinClicks Excel File</label>
                    <input type="file" class="form-control" id="pinclicksExcelFile" name="pinclicksExcelFile" accept=".xlsx, .xls, .csv">
                    <div class="form-text">
                      Excel file should have columns with these headers:
                      <ul class="mt-2">
                        <li><strong>Keyword</strong> (required) - The main keyword/recipe name</li>
                        <li><strong>Interests</strong> or <strong>Keywords</strong> (required) - Comma-separated list of related interests/keywords</li>
                        <li><strong>Category</strong> (optional) - Recipe category</li>
                        <li><strong>ImageUrl</strong> (optional) - Reference image URL</li>
                      </ul>
                      <div class="alert alert-info mt-2">
                        <strong>üí° How it works:</strong>
                        <ul class="mb-0">
                          <li><strong>Batch Processing:</strong> Upload multiple keywords with their interests in one file</li>
                          <li><strong>Smart Detection:</strong> System will automatically detect the best column mappings</li>
                        </ul>
                      </div>
                    </div>
                  </div>
                  
                  <div id="pinclicksExcelPreview" class="mb-3 d-none">
                    <h6>Excel Preview</h6>
                    <div class="table-responsive">
                      <table class="table table-sm table-bordered">
                        <thead id="pinclicksExcelPreviewHeader"></thead>
                        <tbody id="pinclicksExcelPreviewBody"></tbody>
                      </table>
                    </div>
                    <p class="text-muted"><small>Showing preview of first 5 rows</small></p>
                  </div>
                </div>
              </div>
              
              <!-- Common Fields -->
              <div class="mb-3">
                <label for="pinclicksCategory" class="form-label">Default Category</label>
                <select class="form-select" id="pinclicksCategory" name="pinclicksCategory">
                  <option value="">No category</option>
                  <option value="Breakfast">Breakfast</option>
                  <option value="Lunch">Lunch</option>
                  <option value="Dinner">Dinner</option>
                  <option value="Dessert">Dessert</option>
                  <option value="Appetizers">Appetizers</option>
                  <option value="Soups">Soups</option>
                  <option value="Salads">Salads</option>
                  <option value="Vegan">Vegan</option>
                  <option value="Vegetarian">Vegetarian</option>
                  <option value="Gluten-Free">Gluten-Free</option>
                  <option value="Low-Carb">Low-Carb</option>
                  <option value="Keto">Keto</option>
                  <option value="Paleo">Paleo</option>
                  <option value="Quick & Easy">Quick & Easy</option>
                  <option value="Budget-Friendly">Budget-Friendly</option>
                </select>
              </div>
              
              <div class="mb-3">
                <label for="pinclicksImageUrl" class="form-label">Default Reference Image URL</label>
                <input type="url" class="form-control" id="pinclicksImageUrl" name="pinclicksImageUrl" placeholder="https://example.com/image.jpg">
              </div>
              
              <div id="pinclicksAnalysisResult" class="mb-3 d-none">
                <div class="card">
                  <div class="card-header">
                    <h6 class="mb-0">Analysis Results</h6>
                  </div>
                  <div class="card-body">
                    <div id="pinclicksResultsContainer">
                      <!-- Results will be displayed here -->
                    </div>
                  </div>
                </div>
              </div>
              
              <button type="button" id="analyzePinclicksBtn" class="btn btn-secondary mb-3">Analyze File</button>
              <button type="button" id="addFromPinclicksBtn" class="btn btn-primary mb-3 d-none">Add Keywords with Interests</button>

              <div class="mb-3">
                <label for="pinclicksPinterestBoard" class="form-label">Pinterest Board</label>
                <select class="form-select" id="pinclicksPinterestBoard" name="pinclicksPinterestBoard">
                  <%
                    const pinterestBoardsListPinclicks = (promptConfig && promptConfig.pinterestBoards) ?
                      promptConfig.pinterestBoards.split(',').map(b => b.trim()) :
                      ['Breakfast', 'Lunch', 'Dinner', 'Dessert'];
                    pinterestBoardsListPinclicks.forEach(board => {
                  %>
                    <option value="<%= board %>" <%= board === 'Dinner' ? 'selected' : '' %>><%= board %></option>
                  <% }); %>
                </select>
                <div class="form-text">Select the Pinterest board for these keywords</div>
              </div>
            </div>

          </div>

          <div class="mb-3">
            <label for="defaultCategory" class="form-label">Default Category (for keywords without category)</label>
            <select class="form-select" id="defaultCategory" name="defaultCategory">
              <option value="">No category</option>
              <option value="Breakfast">Breakfast</option>
              <option value="Lunch">Lunch</option>
              <option value="Dinner">Dinner</option>
              <option value="Dessert">Dessert</option>
              <option value="Appetizers">Appetizers</option>
              <option value="Soups">Soups</option>
              <option value="Salads">Salads</option>
              <option value="Vegan">Vegan</option>
              <option value="Vegetarian">Vegetarian</option>
              <option value="Gluten-Free">Gluten-Free</option>
              <option value="Low-Carb">Low-Carb</option>
              <option value="Keto">Keto</option>
              <option value="Paleo">Paleo</option>
              <option value="Quick & Easy">Quick & Easy</option>
              <option value="Budget-Friendly">Budget-Friendly</option>
            </select>
          </div>
          
          <div class="mb-3">
            <label for="defaultInterests" class="form-label">Default Interests (for keywords without interests)</label>
            <input type="text" class="form-control" id="defaultInterests" name="defaultInterests" value="">
          </div>
          
          <button type="submit" id="addBtn" class="btn btn-primary">Add Keywords</button>
        </form>
      </div>
    </div>
  </div>
  
  <!-- Keywords List Section -->
  <div class="col-md-7">
    <div class="card">
      <div class="card-header">
        <div class="d-flex justify-content-between align-items-center">
          <h5 class="card-title mb-0">Keywords List</h5>
          <div>
            <button id="deleteSelectedBtn" class="btn btn-sm btn-danger me-2" disabled>Delete Selected</button>
            <!-- Crop Images Button -->
            <button id="cropImagesBtn" class="btn btn-primary" >
              Crop Selected Images
            </button>
            <button id="refreshBtn" class="btn btn-sm btn-secondary">
              <i class="bi bi-arrow-clockwise"></i> Refresh
            </button>
          </div>
        </div>
      </div>
      <div class="card-body">
        <!-- Search and Filter -->
        <div class="row mb-3 g-2">
          <div class="col-md-4">
            <form id="searchForm" class="d-flex">
              <input type="text" class="form-control me-2" id="searchInput" name="search" placeholder="Search keywords..." value="<%= search || '' %>">
              <button type="submit" class="btn btn-primary">
                <i class="bi bi-search"></i>
              </button>
            </form>
          </div>
          <div class="col-md-2">
            <select id="statusFilter" class="form-select">
              <option value="" <%= !status ? 'selected' : '' %>>Status</option>
              <option value="pending" <%= status === 'pending' ? 'selected' : '' %>>Pending</option>
              <option value="processed" <%= status === 'processed' ? 'selected' : '' %>>Processed</option>
              <option value="failed" <%= status === 'failed' ? 'selected' : '' %>>Failed</option>
            </select>
          </div>
          <div class="col-md-2">
            <select id="pinclicksFilter" class="form-select">
              <option value="">PinClicks</option>
              <option value="failed" <%= pinclicksFilter === 'failed' ? 'selected' : '' %>>Failed PinClicks</option>
              <option value="no_data" <%= pinclicksFilter === 'no_data' ? 'selected' : '' %>>No PinClicks Data</option>
            </select>
          </div>
          <div class="col-md-2">
            <select id="imageFilter" class="form-select">
              <option value="">Image</option>
              <option value="no_image" <%= imageFilter === 'no_image' ? 'selected' : '' %>>No Image</option>
              <option value="has_image" <%= imageFilter === 'has_image' ? 'selected' : '' %>>Has Image</option>
            </select>
          </div>
          <div class="col-md-2">
            <select id="wpFilter" class="form-select">
              <option value="" <%= !wpFilter ? 'selected' : '' %>>WordPress</option>
              <option value="published" <%= wpFilter === 'published' ? 'selected' : '' %>>WP Published</option>
              <option value="not_published" <%= wpFilter === 'not_published' ? 'selected' : '' %>>WP Not Published</option>
            </select>
          </div>
        </div>

        <!-- Select All Checkbox Row -->
        <% if (keywords && keywords.length > 0) { %>
          <div class="row mb-3">
            <div class="col-12">
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="selectAllCheckbox" style="transform: scale(1.2);">
                <label class="form-check-label fw-bold" for="selectAllCheckbox">
                  Select All Keywords
                </label>
                <span class="ms-3 text-muted" id="selectionCounter">0 selected</span>
              </div>
            </div>
          </div>
        <% } %>

        <div id="statusMessage"></div>
        <div id="processingProgress" class="d-none">
          <!-- Workflow-Based Progress Display -->
          <div class="card mb-3">
            <div class="card-header bg-light">
              <div class="row align-items-center">
                <div class="col">
                  <h6 class="mb-0 text-primary">
                    <i class="fas fa-cog fa-spin me-2"></i>
                    Content Generation Pipeline
                  </h6>
                </div>
                <div class="col-auto">
                  <span class="badge bg-info me-2" id="progressCount">0 / 0</span>
                  <button type="button" class="btn btn-sm btn-warning" id="pauseProcessingBtn">
                    <i class="fas fa-pause me-1"></i>Pause
                  </button>
                  <button type="button" class="btn btn-sm btn-success d-none" id="resumeProcessingBtn">
                    <i class="fas fa-play me-1"></i>Resume
                  </button>
                  <button type="button" class="btn btn-sm btn-outline-danger" id="stopProcessingBtn">
                    <i class="fas fa-stop me-1"></i>Stop
                  </button>
                </div>
              </div>
            </div>
            <div class="card-body">
              <!-- Main Progress Bar -->
              <div class="progress mb-4" style="height: 20px;">
                <div class="progress-bar progress-bar-striped progress-bar-animated" 
                     role="progressbar" style="width: 0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                  <span class="fw-bold" id="progressPercentage">0%</span>
                </div>
              </div>
              
              <!-- Workflow Steps -->
              <div class="row text-center mb-3">
                <div class="col">
                  <div class="workflow-step" id="step-recipe">
                    <div class="step-icon">üçΩÔ∏è</div>
                    <div class="step-label">Recipe Generation</div>
                    <div class="step-status">Pending</div>
                  </div>
                </div>
                <div class="col">
                  <div class="workflow-step" id="step-facebook">
                    <div class="step-icon">üìò</div>
                    <div class="step-label">Facebook Content</div>
                    <div class="step-status">Pending</div>
                  </div>
                </div>
                <div class="col">
                  <div class="workflow-step" id="step-midjourney">
                    <div class="step-icon">üé®</div>
                    <div class="step-label">AI Image Prompt</div>
                    <div class="step-status">Pending</div>
                  </div>
                </div>
                <div class="col">
                  <div class="workflow-step" id="step-discord">
                    <div class="step-icon">üí¨</div>
                    <div class="step-label">Discord Processing</div>
                    <div class="step-status">Pending</div>
                  </div>
                </div>
                <div class="col">
                  <div class="workflow-step" id="step-pinterest">
                    <div class="step-icon">üìå</div>
                    <div class="step-label">Pinterest Content</div>
                    <div class="step-status">Pending</div>
                  </div>
                </div>
                <div class="col">
                  <div class="workflow-step" id="step-blog">
                    <div class="step-icon">üìù</div>
                    <div class="step-label">Blog Post</div>
                    <div class="step-status">Pending</div>
                  </div>
                </div>
              </div>
              
              <!-- Summary Stats -->
              <div class="row text-center mb-3">
                <div class="col-3">
                  <span class="text-success fw-bold" id="successCount">0</span>
                  <small class="text-muted d-block">Completed</small>
                </div>
                <div class="col-3">
                  <span class="text-danger fw-bold" id="failedCount">0</span>
                  <small class="text-muted d-block">Failed</small>
                </div>
                <div class="col-3">
                  <span class="text-info fw-bold" id="remainingCount">0</span>
                  <small class="text-muted d-block">Remaining</small>
                </div>
                <div class="col-3">
                  <span class="fw-bold" id="elapsedTime">00:00</span>
                  <small class="text-muted d-block">Elapsed</small>
                </div>
              </div>
              
              <!-- Current Status -->
              <div class="bg-light rounded p-3 text-center">
                <p class="mb-0 fw-medium" id="progressText">Starting content generation...</p>
                <small class="text-muted" id="currentKeyword"></small>
              </div>
            </div>
          </div>
        </div>

        <!-- Keywords List Layout -->
        <% if (keywords && keywords.length > 0) { %>
          <div class="keywords-vertical-list">
            <% keywords.forEach(function(keyword, index) { %>
              <div class="keyword-card mb-3 border rounded p-3" data-id="<%= keyword.id %>" data-status="<%= keyword.status %>">
                <div class="row align-items-center">
                  <!-- Selection Checkbox -->
                  <div class="col-auto pe-3">
                    <div class="form-check">
                      <input class="form-check-input keyword-checkbox" type="checkbox" value="<%= keyword.id %>"
                             id="keyword_<%= keyword.id %>" style="transform: scale(1.3); margin-top: 2px;">
                      <label class="form-check-label visually-hidden" for="keyword_<%= keyword.id %>">
                        Select <%= keyword.keyword %>
                      </label>
                    </div>
                  </div>
                  
                  <!-- Number -->
                  <div class="col-auto pe-3">
                    <div class="keyword-number bg-primary text-white rounded-circle d-flex align-items-center justify-content-center" 
                         style="width: 35px; height: 35px; font-size: 14px; font-weight: bold;">
                      <%= index + 1 %>
                    </div>
                  </div>
                  
                  <!-- Image -->
<div class="col-auto pe-3">
  <% if (keyword.image_url) { %>
    <% 
      // Handle different types of image URLs
      let imageUrl = keyword.image_url;
      
      // Check if it's a base64 data URL (from cropped images)
      if (imageUrl.startsWith('data:image/')) {
        // Use the data URL directly - no processing needed
        // Data URLs are complete and self-contained
      }
      // Check if it's already a complete HTTP URL
      else if (imageUrl.startsWith('http')) {
        // Use as-is
      }
      // Handle relative/local file paths
      else {
        // If it's a relative path, ensure it starts with /
        if (!imageUrl.startsWith('/')) {
          imageUrl = '/' + imageUrl;
        }
        // If it's meant to be in recipe_images but doesn't have the path
        if (!imageUrl.includes('recipe_images')) {
          imageUrl = '/recipe_images/' + imageUrl.split('/').pop();
        }
      }
    %>
    <img src="<%= imageUrl %>" alt="<%= keyword.keyword %>" 
         class="keyword-image rounded border" style="width: 80px; height: 80px; object-fit: cover;"
         onerror="console.error('Image load error for keyword <%= keyword.id %>:', this.src.substring(0, 50) + '...'); this.onerror=null; this.src='/images/placeholder.png';"
         onload="console.log('‚úÖ Image loaded successfully for keyword <%= keyword.id %>', this.src.startsWith('data:') ? 'data URL (' + Math.round(this.src.length/1024) + 'KB)' : this.src);">
  <% } else { %>
    <div class="keyword-image-placeholder bg-light border rounded d-flex align-items-center justify-content-center" 
         style="width: 80px; height: 80px; color: #6c757d;">
      <i class="bi bi-image" style="font-size: 24px;"></i>
    </div>
  <% } %>
</div>
                  
                  <!-- Keyword Details -->
                  <div class="col">
                    <h6 class="keyword-title mb-2"><%= keyword.keyword %></h6>

                    <!-- Discord Image URL Field (for fallback when image_url fails) -->
                    <div class="mb-2">
                      <div class="input-group input-group-sm">
                        <span class="input-group-text bg-secondary text-white" style="font-size: 11px;">
                          <i class="bi bi-discord me-1"></i> Discord Fallback URL
                        </span>
                        <input type="text"
                               class="form-control form-control-sm discord-image-url-input"
                               data-keyword-id="<%= keyword.id %>"
                               value="<%= keyword.discord_image_url || '' %>"
                               placeholder="Paste Discord image URL here if original image fails"
                               style="font-size: 11px;">
                        <button class="btn btn-sm btn-success save-discord-url-btn"
                                data-keyword-id="<%= keyword.id %>"
                                type="button">
                          <i class="bi bi-check"></i> Save
                        </button>
                      </div>
                      <small class="text-muted" style="font-size: 10px;">
                        üí° If image fails to load in Midjourney, upload to Discord and paste the URL here
                      </small>
                    </div>

                   <div class="keyword-meta mb-2">
  <% if (keyword.category) { %>
    <span class="badge bg-secondary me-2"><%= keyword.category %></span>
  <% } %>
  
  <!-- Recipe Type Badge -->
  <% if (keyword.full_recipe && keyword.full_recipe.trim()) { %>
    <span class="badge bg-info me-2">üìù FULL RECIPE</span>
  <% } else { %>
    <span class="badge bg-warning me-2">ü§ñ AI RECIPE</span>
  <% } %>
  
  <!-- NEW SIMPLE BADGE SYSTEM -->
  <!-- Content Status Badge -->
  <% if (keyword.status === 'pending') { %>
    <span class="badge bg-warning me-2" data-badge="content">üìù PENDING</span>
  <% } else if (keyword.status === 'processing') { %>
    <span class="badge bg-info me-2" data-badge="content">üîÑ PROCESSING</span>
  <% } else if (keyword.status === 'processed') { %>
    <span class="badge bg-success me-2" data-badge="content">‚úÖ COMPLETED</span>
  <% } else if (keyword.status === 'failed') { %>
    <span class="badge bg-danger me-2" data-badge="content">‚ùå FAILED</span>
  <% } %>
  
  <!-- Image Status Badge -->
  <% if (keyword.status === 'processed' && keyword.recipe_id) { %>
    <span class="badge bg-secondary me-2 image-status-badge" data-badge="image" data-recipe-id="<%= keyword.recipe_id %>">üñºÔ∏è CHECKING...</span>
  <% } else { %>
    <span class="badge bg-info text-white me-2" data-badge="image">‚ûñ NO IMAGE</span>
  <% } %>

  <!-- WordPress Status Badge -->
  <% if (keyword.wp_post_id) { %>
    <span class="badge me-2" style="background-color: #21759b;" data-badge="wordpress" title="<%= keyword.wp_post_url || '' %>">WP PUBLISHED</span>
  <% } else if (keyword.status === 'processed' && keyword.recipe_id) { %>
    <span class="badge bg-dark text-muted me-2" data-badge="wordpress">WP NOT PUBLISHED</span>
  <% } %>
</div>
                    
                    <% if (keyword.interests) { %>
                      <small class="text-muted d-block mb-1" title="<%= keyword.interests %>">
                        <i class="bi bi-tags me-1"></i> 
                        <%= keyword.interests.length > 50 ? keyword.interests.substring(0, 47) + '...' : keyword.interests %>
                      </small>
                    <% } %>
                    
                    <small class="text-muted d-block">
                      <i class="bi bi-clock me-1"></i> <%= new Date(keyword.added_at).toLocaleString() %>
                      <% if (keyword.owner_name) { %>
                        | <i class="bi bi-person me-1"></i> <%= keyword.owner_name %>
                      <% } %>
                    </small>
                  </div>
                  
                  <!-- Actions -->
                  <div class="col-auto">
                    <div class="btn-group-vertical btn-group-sm">
                      <% if (keyword.status === 'processed' && keyword.recipe_id) { %>
                        <a href="/recipe/<%= keyword.recipe_id %>" class="btn btn-sm btn-primary mb-1">
                          <i class="bi bi-eye"></i> View
                        </a>
                        <button type="button" class="btn btn-sm btn-info regenerate-image-btn mb-1" data-recipe-id="<%= keyword.recipe_id %>">
                          <i class="bi bi-arrow-repeat"></i> Regenerate Image
                        </button>
                        <button type="button" class="btn btn-sm btn-warning regenerate-pinterest-btn mb-1" data-keyword-id="<%= keyword.id %>" data-recipe-id="<%= keyword.recipe_id %>" data-keyword="<%= keyword.keyword %>">
                          <i class="bi bi-pinterest"></i> Regenerate Pinterest
                        </button>
                      <% } else if (keyword.status === 'pending') { %>
                        <button type="button" class="btn btn-sm btn-success process-btn mb-1" data-id="<%= keyword.id %>">
                          <i class="bi bi-play"></i> Process
                        </button>
                        <button type="button" class="btn btn-sm btn-info run-pinclicks-btn mb-1" data-id="<%= keyword.id %>" data-keyword="<%= keyword.keyword %>">
                          <i class="bi bi-pinterest"></i> Pinclicks
                        </button>
                      <% } else if (keyword.status === 'failed') { %>
                        <button type="button" class="btn btn-sm btn-warning retry-btn mb-1" data-id="<%= keyword.id %>">
                          <i class="bi bi-arrow-clockwise"></i> Retry
                        </button>
                        <button type="button" class="btn btn-sm btn-info run-pinclicks-btn mb-1" data-id="<%= keyword.id %>" data-keyword="<%= keyword.keyword %>">
                          <i class="bi bi-pinterest"></i> Pinclicks
                        </button>
                      <% } %>
                    </div>
                  </div>
                </div>
              </div>
            <% }); %>
          </div>
          
          <!-- Pagination -->
          <% if (totalPages > 1) { %>
            <nav aria-label="Keywords pagination">
              <ul class="pagination justify-content-center">
                <% if (currentPage > 1) { %>
                  <li class="page-item">
                    <a class="page-link" href="/keywords?page=<%= currentPage - 1 %><%= status ? '&status=' + status : '' %><%= search ? '&search=' + search : '' %>">Previous</a>
                  </li>
                <% } else { %>
                  <li class="page-item disabled">
                    <span class="page-link">Previous</span>
                  </li>
                <% } %>
                
                <% for (let i = 1; i <= totalPages; i++) { %>
                  <% if (i === currentPage) { %>
                    <li class="page-item active">
                      <span class="page-link"><%= i %></span>
                    </li>
                  <% } else if (i === 1 || i === totalPages || (i >= currentPage - 2 && i <= currentPage + 2)) { %>
                    <li class="page-item">
                      <a class="page-link" href="/keywords?page=<%= i %><%= status ? '&status=' + status : '' %><%= search ? '&search=' + search : '' %>"><%= i %></a>
                    </li>
                  <% } else if (i === currentPage - 3 || i === currentPage + 3) { %>
                    <li class="page-item disabled">
                      <span class="page-link">...</span>
                    </li>
                  <% } %>
                <% } %>
                
                <% if (currentPage < totalPages) { %>
                  <li class="page-item">
                    <a class="page-link" href="/keywords?page=<%= currentPage + 1 %><%= status ? '&status=' + status : '' %><%= search ? '&search=' + search : '' %>">Next</a>
                  </li>
                <% } else { %>
                  <li class="page-item disabled">
                    <span class="page-link">Next</span>
                  </li>
                <% } %>
              </ul>
            </nav>
          <% } %>
        <% } else { %>
          <div class="alert alert-info">
            No keywords found. Add some keywords to get started.
          </div>
        <% } %>
      </div>
    </div>
  </div>
</div>

<!-- Simple Crop Modal -->
<div class="modal fade" id="cropModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-xl">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Crop Image</h5>

        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body">
        <div id="cropContainer">
          <!-- Cropper will be inserted here dynamically -->
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-success" id="saveCroppedImages">
          <i class="bi bi-check2"></i> Save Cropped Images
        </button>
      </div>
    </div>
  </div>
</div>

<!-- Other Modals (kept as-is) -->
<!-- Process Result Modal -->
<div class="modal fade" id="processResultModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Processing Results</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="table-responsive">
          <table class="table table-hover" id="resultTable">
            <thead>
              <tr>
                <th>Keyword</th>
                <th>Status</th>
                <th>Message</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="resultTableBody"></tbody>
          </table>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- Confirmation Modal -->
<div class="modal fade" id="confirmModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Confirmation</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p id="confirmMessage">Are you sure you want to perform this action?</p>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-danger" id="confirmButton">Confirm</button>
      </div>
    </div>
  </div>
</div>

<!-- Prompt Edit Modal -->
<div class="modal fade" id="promptEditModal" tabindex="-1" aria-labelledby="promptEditModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="promptEditModalLabel">Edit Midjourney Prompt</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div id="promptEditAlert" class="alert alert-danger d-none">
          <p><strong>Safety check failed!</strong> Your prompt contains potentially blocked terms:</p>
          <p id="promptEditBlockedTerms"></p>
          <p>Please modify these terms to avoid being blocked by Midjourney's safety filter.</p>
        </div>
        
        <form id="promptEditForm">
          <input type="hidden" id="promptEditRecipeId" name="recipeId">
          
          <div class="mb-3">
            <label for="promptEditText" class="form-label">Midjourney Prompt:</label>
            <textarea class="form-control" id="promptEditText" name="prompt" rows="6" required></textarea>
            <div class="form-text">
              Edit this prompt to avoid terms that might trigger Midjourney's safety filter.
              <br>Common issues: terms like "skillet" (contains "kill"), "skillful", etc.
            </div>
          </div>
          
          <div class="mb-3">
            <label class="form-label">Troubleshooting Tips:</label>
            <ul class="small">
              <li>Replace "skillet" with "pan" or "cooking pan"</li>
              <li>Replace problematic words with synonyms</li>
              <li>If specific ingredients are causing issues, try rewording them</li>
            </ul>
          </div>
        </form>
        
        <div id="promptEditSpinner" class="text-center d-none">
          <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
          </div>
          <p class="mt-2">Generating image with edited prompt...</p>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" id="promptEditSaveBtn">Generate Image</button>
      </div>
    </div>
  </div>
</div>


<!-- Include Scripts -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.css">
<link rel="stylesheet" href="/css/image-cropper.css">

<script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/date-fns@2.30.0/index.min.js"></script>
<script src="/js/image-cropper.js"></script>

<style>
/* Custom styles for vertical keyword layout */
.keyword-card {
  transition: all 0.2s ease;
  background: #1E243C;
}

.keyword-card:hover {
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  transform: translateY(-2px);
}

.keyword-image {
  border: 2px solid #e9ecef;
}

.keyword-image-placeholder {
  border: 2px dashed #e9ecef;
}

.keyword-title {
  font-weight: 600;
  color: white;
}

.keyword-meta .badge {
  font-size: 0.75rem;
}

.keyword-number {
  font-family: 'Arial', sans-serif;
}
</style>

<script>
// Page-specific JavaScript for Keywords Management
document.addEventListener('DOMContentLoaded', function() {
  // Excel file handling variables
  let parsedExcelData = null;
  
  // Enhanced PinClicks Analysis with Excel Support
  let parsedPinclicksData = null;
  let analyzedPinclicksResults = null;
  
  
  // Helper to safely add click handlers
  function safeAddClickHandler(elementId, handler) {
    const element = document.getElementById(elementId);
    if (element) {
      console.log(`‚úÖ Found element ${elementId}, adding click handler`);
      element.onclick = handler;
      
      // Debug: Test the handler immediately
      console.log(`üîç Testing click handler for ${elementId}:`, typeof handler);
    } else {
      console.warn(`‚ö†Ô∏è Element ${elementId} not found, cannot add click handler`);
    }
  }

  // Get current active tab
  function getCurrentActiveTab() {
    const manualTab = document.getElementById('manual-tab');
    const excelTab = document.getElementById('excel-tab');
    const pinclicksTab = document.getElementById('pinclicks-tab');
    
    if (manualTab && manualTab.classList.contains('active')) return 'manual-tab';
    if (excelTab && excelTab.classList.contains('active')) return 'excel-tab';
    if (pinclicksTab && pinclicksTab.classList.contains('active')) return 'pinclicks-tab';
    
    return 'manual-tab';
  }

  // Get selected template settings (currently defaults to no template)
  function getSelectedTemplate() {
    return {
      useTemplate: false,
      templateId: null
    };
  }

  // ENHANCED: Image status checking with comprehensive debugging
  function debugImageStatusSetup() {
    console.log('=== IMAGE STATUS DEBUG REPORT ===');
    
    const allCells = document.querySelectorAll('.image-status-cell');
    const cellsWithRecipeId = document.querySelectorAll('.image-status-cell[data-recipe-id]');
    
    console.log(`Total image status cells: ${allCells.length}`);
    console.log(`Cells with recipe ID: ${cellsWithRecipeId.length}`);
    
    allCells.forEach((cell, index) => {
      const recipeId = cell.getAttribute('data-recipe-id');
      const currentContent = cell.innerHTML.trim();
      
      console.log(`Cell ${index + 1}:`, {
        hasRecipeId: !!recipeId,
        recipeId: recipeId,
        isEmpty: !recipeId || recipeId === 'null' || recipeId === 'undefined' || recipeId === '',
        currentContent: currentContent.substring(0, 50) + '...'
      });
    });
    
    console.log('=== END DEBUG REPORT ===');
  }

  // ENHANCED: Image status checking function
  // SMART IMAGE MONITORING - No more failed status bugs!
  function startSmartImageMonitoring(recipeId, keywordId) {
    console.log(`üñºÔ∏è Starting fast monitoring for recipe ${recipeId}, keyword ${keywordId}`);
    
    let attempts = 0;
    const maxAttempts = 30;
    let currentTimeout;
    
    // IMMEDIATE CHECK: Check right away for existing images
    checkImageStatus();
    
    async function checkImageStatus() {
      attempts++;
      console.log(`üñºÔ∏è Image check attempt ${attempts}/${maxAttempts} for recipe ${recipeId}`);
      
      // Check if keyword was cancelled before continuing image monitoring
      const keywordCard = document.querySelector(`.keyword-card[data-id="${keywordId}"]`);
      if (keywordCard) {
        const currentStatus = keywordCard.getAttribute('data-status');
        if (currentStatus === 'failed') {
          console.log(`üõë Image monitoring stopped - keyword ${keywordId} was cancelled`);
          updateImageBadge(keywordId, 'cancelled');
          return;
        }
      }
      
      try {
        const response = await fetch(`/midjourney/api/recipe/${recipeId}`, {
          method: 'GET',
          headers: { 'Cache-Control': 'no-cache' }
        });
        
        if (!response.ok) {
          console.log(`üñºÔ∏è API not ready yet for recipe ${recipeId} (attempt ${attempts})`);
          
          if (attempts >= maxAttempts) {
            updateImageBadge(keywordId, 'timeout');
            return;
          }
          scheduleNext();
          return;
        }
        
        const data = await response.json();
        
        if (data.success && data.images && data.images.length > 0) {
          const latestImage = data.images[0];
          console.log(`üñºÔ∏è Image status for recipe ${recipeId}:`, latestImage.status);
          
          switch (latestImage.status) {
            case 'completed':
            case 'success':
            case 'done':
              updateImageBadge(keywordId, 'generated');
              return; // Stop monitoring - found completed image
            case 'failed':
              updateImageBadge(keywordId, 'failed');
              return; // Stop monitoring - failed
            case 'pending':
            case 'processing':
            case 'in_progress':
            case 'queued':
              updateImageBadge(keywordId, 'generating');
              break;
            default:
              console.log(`üñºÔ∏è Unknown image status: ${latestImage.status}`);
              updateImageBadge(keywordId, 'generating');
          }
        } else {
          console.log(`üñºÔ∏è No images yet for recipe ${recipeId}, continuing to monitor...`);
          updateImageBadge(keywordId, 'generating');
        }
        
        // Continue checking unless max attempts reached
        if (attempts >= maxAttempts) {
          updateImageBadge(keywordId, 'timeout');
          return;
        }
        
        scheduleNext();
        
      } catch (error) {
        console.log(`üñºÔ∏è Error checking recipe ${recipeId} (attempt ${attempts}):`, error.message);
        
        if (attempts >= maxAttempts) {
          updateImageBadge(keywordId, 'error');
          return;
        }
        
        scheduleNext();
      }
    }
    
    function scheduleNext() {
      // SMART INTERVALS: Fast initially, then slower
      let interval;
      if (attempts <= 3) {
        interval = 2000; // First 3 checks every 2 seconds (for existing images)
      } else if (attempts <= 10) {
        interval = 10000; // Next 7 checks every 10 seconds
      } else {
        interval = 30000; // After that, every 30 seconds
      }
      
      currentTimeout = setTimeout(checkImageStatus, interval);
    }
  }
  
  // ASYNC PROCESSING: Poll keyword status instead of waiting for response  
  function startKeywordStatusPolling(keywordId) {
    console.log(`üì° Starting status polling for keyword: ${keywordId}`);
    
    let attempts = 0;
    const maxAttempts = 60; // Poll for up to 10 minutes (60 * 10s)
    
    const pollInterval = setInterval(async () => {
      attempts++;
      console.log(`üì° Status poll attempt ${attempts}/${maxAttempts} for keyword ${keywordId}`);
      
      try {
        const response = await fetch(`/api/keywords/status/${keywordId}`, {
          method: 'GET',
          headers: { 'Cache-Control': 'no-cache' }
        });
        
        if (!response.ok) {
          console.log(`üì° Status API not ready yet (attempt ${attempts})`);
          
          // If we've tried many times and still getting errors, give up
          if (attempts >= maxAttempts) {
            clearInterval(pollInterval);
            updateKeywordRowInUI(keywordId, { status: 'failed', message: 'Polling timeout' });
            showStatus('error', 'Processing status check timed out');
          }
          return;
        }
        
        const data = await response.json();
        console.log(`üì° Keyword status update:`, data);
        
        if (data.status === 'processed') {
          clearInterval(pollInterval);
          updateKeywordRowInUI(keywordId, data);
          showStatus('success', 'Keyword processed successfully!');
          
          // Start image monitoring
          if (data.recipeId) {
            setTimeout(() => startSmartImageMonitoring(data.recipeId, keywordId), 10000);
          }
          
        } else if (data.status === 'failed') {
          clearInterval(pollInterval);
          updateKeywordRowInUI(keywordId, data);
          showStatus('error', 'Processing failed: ' + (data.message || 'Unknown error'));
          
        } else if (data.status === 'processing') {
          // Still processing, continue polling and update workflow
          console.log(`üì° Still processing... (${data.processingTime || 'unknown'} elapsed)`);
          
          // Update workflow based on real status
          updateWorkflowBasedOnStatus(keywordId, 'processing', data);
          
        } else {
          console.log(`üì° Unexpected status: ${data.status}`);
        }
        
        // Stop after max attempts to avoid infinite polling
        if (attempts >= maxAttempts) {
          clearInterval(pollInterval);
          showStatus('warning', 'Processing is taking longer than expected. Please refresh to check status.');
        }
        
      } catch (error) {
        console.log(`üì° Error polling status (attempt ${attempts}):`, error.message);
        
        // Stop on too many errors
        if (attempts >= maxAttempts) {
          clearInterval(pollInterval);
          showStatus('error', 'Unable to check processing status. Please refresh the page.');
        }
      }
    }, 10000); // Poll every 10 seconds
  }

  // Helper function to update image badge without affecting content status
  function updateImageBadge(keywordId, status) {
    const card = document.querySelector(`.keyword-card[data-id="${keywordId}"]`);
    if (!card) return;
    
    const imageBadge = card.querySelector('[data-badge="image"]');
    if (!imageBadge) return;
    
    switch (status) {
      case 'generated':
        imageBadge.className = 'badge bg-success me-2';
        imageBadge.textContent = 'üñºÔ∏è GENERATED';
        break;
      case 'generating':
        imageBadge.className = 'badge bg-warning me-2';
        imageBadge.textContent = 'üñºÔ∏è GENERATING';
        break;
      case 'failed':
        imageBadge.className = 'badge bg-danger me-2';
        imageBadge.textContent = 'üñºÔ∏è FAILED';
        break;
      case 'timeout':
        imageBadge.className = 'badge bg-secondary me-2';
        imageBadge.textContent = 'üñºÔ∏è CHECK RECIPE';
        break;
      case 'error':
        imageBadge.className = 'badge bg-warning me-2';
        imageBadge.textContent = 'üñºÔ∏è CHECK RECIPE';
        break;
      case 'cancelled':
        imageBadge.className = 'badge bg-secondary me-2';
        imageBadge.textContent = 'üñºÔ∏è CANCELLED';
        break;
    }
    
    console.log(`üñºÔ∏è Updated image badge for keyword ${keywordId}: ${status}`);
  }

  // OLD IMAGE STATUS CHECK (kept for compatibility)
  async function checkImageStatus() {
    const imageBadges = document.querySelectorAll('.image-status-badge[data-recipe-id]');
    
    console.log(`üñºÔ∏è Checking image status for ${imageBadges.length} recipes`);
    
    imageStatusCells.forEach(async (cell, index) => {
      const recipeId = cell.getAttribute('data-recipe-id');
      
      console.log(`Cell ${index + 1}: Recipe ID = "${recipeId}"`);
      
      // Enhanced validation
      if (!recipeId || recipeId === 'null' || recipeId === 'undefined' || recipeId.trim() === '' || recipeId === 'null') {
        console.warn(`Cell ${index + 1}: Invalid recipe ID, skipping`);
        cell.innerHTML = `<span class="badge bg-secondary">‚ùì No Recipe ID</span>`;
        return;
      }
      
      try {
        console.log(`Fetching status for recipe: ${recipeId}`);
        
        const response = await fetch(`/midjourney/api/recipe/${recipeId}`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            'Cache-Control': 'no-cache'
          }
        });
        
        console.log(`Recipe ${recipeId}: Response status = ${response.status}, OK = ${response.ok}`);
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error(`Recipe ${recipeId}: HTTP ${response.status} - ${errorText}`);
          
          if (response.status === 401) {
            cell.innerHTML = `<span class="badge bg-warning">üîê Unauthorized</span>`;
          } else if (response.status === 403) {
            cell.innerHTML = `<span class="badge bg-warning">üö´ Forbidden</span>`;
          } else if (response.status === 404) {
            cell.innerHTML = `<span class="badge bg-secondary">‚ùì Not Found</span>`;
          } else {
            cell.innerHTML = `<span class="badge bg-danger">‚ö†Ô∏è HTTP ${response.status}</span>`;
          }
          return;
        }
        
        const responseText = await response.text();
        console.log(`Recipe ${recipeId}: Raw response length = ${responseText.length}`);
        console.log(`Recipe ${recipeId}: Response preview = ${responseText.substring(0, 200)}...`);
        
        let data;
        try {
          data = JSON.parse(responseText);
        } catch (parseError) {
          console.error(`Recipe ${recipeId}: Failed to parse JSON:`, parseError);
          console.error(`Recipe ${recipeId}: Raw response was:`, responseText);
          cell.innerHTML = `<span class="badge bg-danger">üìÑ Parse Error</span>`;
          return;
        }
        
        console.log(`Recipe ${recipeId}: Parsed data structure:`, {
          success: data.success,
          hasImages: !!(data.images && data.images.length > 0),
          imageCount: data.images ? data.images.length : 0,
          dataKeys: Object.keys(data)
        });
        
        if (data.success && data.images && Array.isArray(data.images) && data.images.length > 0) {
          const latestImage = data.images[0];
          console.log(`Recipe ${recipeId}: Latest image:`, {
            status: latestImage.status,
            id: latestImage.id,
            hasUrl: !!latestImage.image_url
          });
          
          // Handle all possible status values with emojis
          switch (latestImage.status) {
            case 'completed':
            case 'success':
            case 'done':
              cell.innerHTML = `<span class="badge bg-success">‚úÖ Generated</span>`;
              break;
            case 'pending':
            case 'processing':
            case 'in_progress':
            case 'queued':
              cell.innerHTML = `<span class="badge bg-warning">‚è≥ Pending</span>`;
              break;
            case 'failed':
            case 'error':
              cell.innerHTML = `<span class="badge bg-danger">‚ùå Failed</span>`;
              break;
            default:
              cell.innerHTML = `<span class="badge bg-info">üîÑ ${latestImage.status}</span>`;
          }
        } else if (data.success === false) {
          console.log(`Recipe ${recipeId}: API returned success=false:`, data.message || data.error);
          cell.innerHTML = `<span class="badge bg-secondary">‚≠ï No Images</span>`;
        } else {
          console.log(`Recipe ${recipeId}: No images in successful response`);
          cell.innerHTML = `<span class="badge bg-secondary">‚≠ï No Images</span>`;
        }
        
      } catch (error) {
        console.error(`Recipe ${recipeId}: Fetch error:`, {
          message: error.message,
          name: error.name,
          stack: error.stack
        });
        
        if (error.name === 'TypeError' && error.message.includes('fetch')) {
          cell.innerHTML = `<span class="badge bg-danger">üåê Network Error</span>`;
        } else if (error.message.includes('JSON')) {
          cell.innerHTML = `<span class="badge bg-danger">üìÑ Parse Error</span>`;
        } else {
          cell.innerHTML = `<span class="badge bg-danger">‚ö†Ô∏è Error</span>`;
        }
      }
    });
  }

  // Smart monitoring with error backoff
  let imageStatusCheckInterval;
  let consecutiveErrors = 0;

  function startImageStatusMonitoring() {
    if (imageStatusCheckInterval) {
      clearInterval(imageStatusCheckInterval);
    }
    
    imageStatusCheckInterval = setInterval(async () => {
      try {
        await checkImageStatus();
        consecutiveErrors = 0;
      } catch (error) {
        consecutiveErrors++;
        console.error('Image status check failed:', error);
        
        if (consecutiveErrors >= 3) {
          clearInterval(imageStatusCheckInterval);
          console.warn('Too many errors, reducing check frequency');
          imageStatusCheckInterval = setInterval(checkImageStatus, 120000); // 2 minutes
        }
      }
    }, 30000); // 30 seconds
  }

  // Update selected count
  function updateSelectedCount() {
    const count = document.querySelectorAll('.keyword-checkbox:checked').length;
    const countElement = document.getElementById('selectedCount');
    const selectionCounter = document.getElementById('selectionCounter');
    
    if (countElement) {
      countElement.textContent = count;
    }
    
    if (selectionCounter) {
      selectionCounter.textContent = `${count} selected`;
    }
    
    const processBtn = document.getElementById('processSelectedBtn');
    if (processBtn) {
      processBtn.disabled = count === 0;
    }
    
    const deleteSelectedBtn = document.getElementById('deleteSelectedBtn');
    if (deleteSelectedBtn) {
      deleteSelectedBtn.disabled = count === 0;
    }
    
  }

  // Setup checkbox listeners
  document.querySelectorAll('.keyword-checkbox').forEach(checkbox => {
    checkbox.addEventListener('change', updateSelectedCount);
  });
  
  // Select All Checkbox
  const selectAllCheckbox = document.getElementById('selectAllCheckbox');
  if (selectAllCheckbox) {
    selectAllCheckbox.addEventListener('change', function() {
      const checkboxes = document.querySelectorAll('.keyword-checkbox:not(:disabled)');
      checkboxes.forEach(checkbox => {
        checkbox.checked = this.checked;
      });
      updateSelectedCount();
    });
  }
  
  // Status filter change
  const statusFilter = document.getElementById('statusFilter');
  if (statusFilter) {
    statusFilter.addEventListener('change', applyFilters);
  }

  // PinClicks filter change
  const pinclicksFilter = document.getElementById('pinclicksFilter');
  if (pinclicksFilter) {
    pinclicksFilter.addEventListener('change', applyFilters);
  }

  // Image filter change
  const imageFilter = document.getElementById('imageFilter');
  if (imageFilter) {
    imageFilter.addEventListener('change', applyFilters);
  }

  // WordPress filter change
  const wpFilterEl = document.getElementById('wpFilter');
  if (wpFilterEl) {
    wpFilterEl.addEventListener('change', applyFilters);
  }

  // Apply all filters function
  function applyFilters() {
    const params = new URLSearchParams();

    const status = document.getElementById('statusFilter')?.value;
    const pinclicks = document.getElementById('pinclicksFilter')?.value;
    const image = document.getElementById('imageFilter')?.value;
    const wordpress = document.getElementById('wpFilter')?.value;
    const search = document.getElementById('searchInput')?.value;

    if (status) params.append('status', status);
    if (pinclicks) params.append('pinclicks', pinclicks);
    if (image) params.append('image', image);
    if (wordpress) params.append('wordpress', wordpress);
    if (search) params.append('search', search);

    window.location.href = '/keywords' + (params.toString() ? '?' + params.toString() : '');
  }
  
  const refreshBtn = document.getElementById('refreshBtn');
  if (refreshBtn) {
    refreshBtn.addEventListener('click', function() {
      const url = new URL(window.location);
      url.searchParams.set('_refresh', Date.now());
      window.location.href = url.toString();
    });
  }

  // Status message function
  function showStatus(type, message) {
    const statusElement = document.getElementById('statusMessage');
    if (!statusElement) return;
    
    let alertClass = 'alert-info';
    if (type === 'error') alertClass = 'alert-danger';
    if (type === 'success') alertClass = 'alert-success';
    if (type === 'warning') alertClass = 'alert-warning';
    
    statusElement.innerHTML = `
      <div class="alert ${alertClass} alert-dismissible fade show" role="alert">
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
      </div>
    `;
    
    statusElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  }

  // Workflow step management
  function resetWorkflowSteps(contentOption = 'all') {
    const allSteps = ['recipe', 'facebook', 'midjourney', 'discord', 'pinterest', 'blog'];
    
    // Define which steps are needed for each content option
    const stepMapping = {
      'facebook': ['recipe', 'facebook', 'midjourney', 'discord'],
      'pinterest': ['recipe', 'pinterest', 'midjourney', 'discord'],
      'all': ['recipe', 'facebook', 'midjourney', 'discord', 'pinterest', 'blog']
    };
    
    const neededSteps = stepMapping[contentOption] || stepMapping['all'];
    
    // Hide all steps first
    allSteps.forEach(step => {
      const element = document.getElementById(`step-${step}`);
      if (element) {
        const col = element.closest('.col');
        if (neededSteps.includes(step)) {
          // Show and reset this step
          col.style.display = 'block';
          element.className = 'workflow-step pending';
          element.querySelector('.step-status').textContent = 'Pending';
        } else {
          // Hide this step
          col.style.display = 'none';
        }
      }
    });
  }
  
  function updateWorkflowStep(step, status, text = null) {
    const element = document.getElementById(`step-${step}`);
    if (element) {
      element.className = `workflow-step ${status}`;
      if (text) {
        element.querySelector('.step-status').textContent = text;
      } else {
        element.querySelector('.step-status').textContent = status.charAt(0).toUpperCase() + status.slice(1);
      }
    }
    
    // Update progress bar to follow workflow steps
    updateWorkflowProgressBar(step, status);
  }
  
  function updateWorkflowProgressBar(step, status) {
    // Define workflow step order and get visible steps
    const allSteps = ['recipe', 'facebook', 'midjourney', 'discord', 'pinterest', 'blog'];
    
    // Get only visible steps (not hidden by content options)
    const visibleSteps = allSteps.filter(stepId => {
      const stepElement = document.getElementById(`step-${stepId}`);
      return stepElement && stepElement.closest('.col').style.display !== 'none';
    });
    
    if (visibleSteps.length === 0) return;
    
    // Find current step index in visible steps
    const currentStepIndex = visibleSteps.indexOf(step);
    if (currentStepIndex === -1) return;
    
    // Calculate progress percentage
    let progressPercentage = 0;
    
    if (status === 'active') {
      // If step is active, progress is at the beginning of this step
      progressPercentage = (currentStepIndex / visibleSteps.length) * 100;
    } else if (status === 'completed') {
      // If step is completed, progress is at the end of this step
      progressPercentage = ((currentStepIndex + 1) / visibleSteps.length) * 100;
    } else if (status === 'failed') {
      // If step failed, keep progress at current step
      progressPercentage = (currentStepIndex / visibleSteps.length) * 100;
    }
    
    // Update progress bar
    const progressBar = document.querySelector('.progress-bar');
    const progressPercentageElement = document.getElementById('progressPercentage');
    
    if (progressBar && progressPercentageElement) {
      progressBar.style.width = `${progressPercentage}%`;
      progressBar.setAttribute('aria-valuenow', Math.round(progressPercentage));
      progressPercentageElement.textContent = `${Math.round(progressPercentage)}%`;
      
      // Add visual feedback based on status
      if (status === 'active') {
        progressBar.classList.add('progress-animated');
        progressBar.style.backgroundImage = 'linear-gradient(90deg, var(--primary-purple) 0%, #8860e6 100%)';
      } else if (status === 'completed') {
        progressBar.classList.remove('progress-animated');
        progressBar.style.backgroundImage = 'linear-gradient(90deg, var(--accent-teal) 0%, #4aecbf 100%)';
      } else if (status === 'failed') {
        progressBar.classList.remove('progress-animated');
        progressBar.style.backgroundImage = 'linear-gradient(90deg, var(--danger-red) 0%, #ff6b63 100%)';
      }
    }
  }
  
  function showWorkflowProgress(step, keyword = '') {
    const stepNames = {
      'recipe': 'Generating recipe content',
      'facebook': 'Creating Facebook post',
      'midjourney': 'Generating AI image prompt',
      'discord': 'Processing in Discord',
      'pinterest': 'Creating Pinterest pins',
      'blog': 'Writing blog post'
    };
    
    updateWorkflowStep(step, 'active', 'Processing');
    document.getElementById('progressText').textContent = stepNames[step] || 'Processing...';
    if (keyword) {
      document.getElementById('currentKeyword').textContent = `Current: ${keyword}`;
    }
  }

  // Real workflow progression based on server status (global function)
  function updateWorkflowBasedOnStatus(keywordId, status, data) {
    const keywordElement = document.querySelector(`[data-id="${keywordId}"]`);
    const keywordText = keywordElement ? keywordElement.querySelector('.keyword-text')?.textContent || keywordId : keywordId;
    
    if (status === 'processing') {
      // Show content generation step based on processing time
      const processingTime = data && data.processingTime ? parseInt(data.processingTime) : 0;
      
      if (processingTime < 30) {
        showWorkflowProgress('recipe', `Generating recipe for: ${keywordText}`);
      } else if (processingTime < 60) {
        // Determine which content step based on contentOption
        const contentOption = localStorage.getItem('currentContentOption') || 'all';
        if (contentOption === 'facebook' || contentOption === 'all') {
          showWorkflowProgress('facebook', `Creating Facebook content for: ${keywordText}`);
        } else if (contentOption === 'pinterest') {
          showWorkflowProgress('pinterest', `Creating Pinterest content for: ${keywordText}`);
        }
      } else if (processingTime < 90) {
        showWorkflowProgress('midjourney', `Generating image prompt for: ${keywordText}`);
      } else {
        // Check if content is done but waiting for images
        showWorkflowProgress('discord', `Waiting for image generation: ${keywordText}`);
      }
    } else if (status === 'processed') {
      // Mark all visible steps as completed
      const visibleSteps = document.querySelectorAll('.workflow-step');
      visibleSteps.forEach(stepElement => {
        if (stepElement.closest('.col').style.display !== 'none') {
          const stepId = stepElement.id.replace('step-', '');
          updateWorkflowStep(stepId, 'completed');
        }
      });
      document.getElementById('progressText').textContent = `‚úÖ Completed: ${keywordText}`;
    } else if (status === 'failed') {
      // Mark first visible step as failed
      const visibleSteps = document.querySelectorAll('.workflow-step');
      for (const stepElement of visibleSteps) {
        if (stepElement.closest('.col').style.display !== 'none') {
          const stepId = stepElement.id.replace('step-', '');
          updateWorkflowStep(stepId, 'failed');
          break;
        }
      }
      document.getElementById('progressText').textContent = `‚ùå Failed: ${keywordText}`;
    }
  }

  // Stop processing functionality
  async function stopProcessing() {
    console.log('üõë Stop processing called');
    
    // Set global cancellation flag
    window.processingCancelled = true;
    console.log('üõë Set global cancellation flag');
    
    // Get all currently processing keywords
    const processingKeywords = document.querySelectorAll('.keyword-card[data-status="processing"]');
    const keywordIds = Array.from(processingKeywords).map(card => card.getAttribute('data-id'));
    
    console.log(`üõë Found ${keywordIds.length} keywords to cancel:`, keywordIds);
    
    // Update UI immediately for all processing keywords
    keywordIds.forEach(keywordId => {
      updateKeywordRowInUI(keywordId, { 
        status: 'failed', 
        message: 'Cancelled by user',
        processed_at: new Date().toISOString()
      });
    });
    
    // Try to cancel on server and debug what happens
    if (keywordIds.length > 0) {
      console.log('üîç Calling normal cancel endpoint...');
      fetch('/api/keywords/cancel', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Cache-Control': 'no-cache'
        },
        body: JSON.stringify({ keywordIds })
      }).then(async response => {
        if (response.ok) {
          const data = await response.json();
          console.log('‚úÖ Server cancellation successful:', data);
          
          // Now debug each keyword individually
          console.log('üîç Starting individual keyword debugging...');
          for (const keywordId of keywordIds) {
            try {
              const debugResponse = await fetch(`/api/keywords/debug-force-cancel/${keywordId}`);
              if (debugResponse.ok) {
                const debugData = await debugResponse.json();
                console.log(`üîç Debug data for keyword ${keywordId}:`, debugData);
              }
            } catch (debugError) {
              console.log(`‚ö†Ô∏è Debug failed for keyword ${keywordId}:`, debugError);
            }
          }
        } else {
          console.log('‚ö†Ô∏è Server cancellation failed, but UI already updated');
        }
      }).catch(error => {
        console.log('‚ö†Ô∏è Server cancellation error, but UI already updated:', error);
      });
    }
    
    // Stop all intervals
    if (window.processingTimeInterval) {
      clearInterval(window.processingTimeInterval);
      window.processingTimeInterval = null;
    }
    
    // Stop batch monitoring
    if (window.batchMonitoringInterval) {
      clearInterval(window.batchMonitoringInterval);
      window.batchMonitoringInterval = null;
    }
    
    // Clear localStorage
    localStorage.removeItem('currentContentOption');
    localStorage.removeItem('processingStartTime');
    
    // Update UI
    document.getElementById('progressText').textContent = `üõë Processing cancelled - ${keywordIds.length} keywords stopped`;
    document.getElementById('currentKeyword').textContent = '';
    
    // Mark all workflow steps as stopped
    const visibleSteps = document.querySelectorAll('.workflow-step');
    visibleSteps.forEach(stepElement => {
      if (stepElement.closest('.col').style.display !== 'none') {
        const stepId = stepElement.id.replace('step-', '');
        updateWorkflowStep(stepId, 'failed');
      }
    });
    
    // Change progress bar to indicate stopped
    const progressBar = document.querySelector('.progress-bar');
    if (progressBar) {
      progressBar.classList.remove('progress-bar-animated');
      progressBar.style.backgroundImage = 'linear-gradient(90deg, #dc3545 0%, #f86a6a 100%)';
    }
    
    // Hide progress bar after a short delay
    setTimeout(() => {
      const progressElement = document.getElementById('processingProgress');
      if (progressElement) {
        progressElement.classList.add('d-none');
        showStatus('success', `‚úÖ Processing cancelled successfully. ${keywordIds.length} keywords marked as cancelled.`);
      }
    }, 3000);
  }

  // Stop button event handler
  safeAddClickHandler('stopProcessingBtn', function() {
    console.log('üõë Stop button clicked!');
    if (confirm('Are you sure you want to cancel the processing? This will mark all processing keywords as cancelled and they will not continue.')) {
      console.log('üõë User confirmed cancellation, calling stopProcessing()');
      stopProcessing();
    } else {
      console.log('üõë User cancelled the cancellation');
    }
  });

  // Pause button handler
  safeAddClickHandler('pauseProcessingBtn', async function() {
    try {
      const resp = await fetch('/api/keywords/pause', { method: 'POST', headers: { 'Content-Type': 'application/json' } });
      const result = await resp.json();
      if (result.success) {
        document.getElementById('pauseProcessingBtn').classList.add('d-none');
        document.getElementById('resumeProcessingBtn').classList.remove('d-none');

        // Stop batch monitoring so we don't start next keyword
        if (window.batchMonitoringInterval) {
          clearInterval(window.batchMonitoringInterval);
        }
        window.processingCancelled = true;

        showStatus('info', 'Processing paused. Current keyword will finish, then processing stops.');
      }
    } catch (error) {
      console.error('Pause error:', error);
    }
  });

  // Resume button handler
  safeAddClickHandler('resumeProcessingBtn', async function() {
    try {
      // Clear pause flag
      await fetch('/api/keywords/resume', { method: 'POST', headers: { 'Content-Type': 'application/json' } });

      document.getElementById('resumeProcessingBtn').classList.add('d-none');
      document.getElementById('pauseProcessingBtn').classList.remove('d-none');
      window.processingCancelled = false;

      // Find all pending keywords that were originally selected
      const pendingCards = document.querySelectorAll('.keyword-card[data-status="pending"]');
      const pendingIds = Array.from(pendingCards).map(card => card.getAttribute('data-id'));

      if (pendingIds.length === 0) {
        showStatus('success', 'All keywords have been processed.');
        return;
      }

      showStatus('info', `Resuming processing of ${pendingIds.length} remaining keywords...`);

      // Re-trigger processing
      const contentOption = localStorage.getItem('currentContentOption') || 'all';
      const response = await fetch('/api/keywords/process-selected', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ keywordIds: pendingIds, contentOption })
      });

      const result = await response.json();
      if (result.success) {
        showStatus('success', 'Processing resumed!');
      }
    } catch (error) {
      console.error('Resume error:', error);
    }
  });

  // Process selected keywords
  const processSelectedButton = document.getElementById('processSelectedBtn');
  if (processSelectedButton) {
    console.log('‚úÖ Found processSelectedBtn, adding click handler');
    processSelectedButton.addEventListener('click', function() {
    const selectedKeywords = Array.from(document.querySelectorAll('.keyword-checkbox:checked'))
      .map(cb => cb.value);
    
    if (selectedKeywords.length === 0) {
      alert('No keywords selected for processing.');
      return;
    }
    
    const optionElement = document.querySelector('input[name="contentOption"]:checked');
    const contentOption = optionElement ? optionElement.value : 'facebook';
    
    if (confirm(`Process ${selectedKeywords.length} keywords with ${contentOption} option?`)) {
      const statusElement = document.getElementById('statusMessage');
      if (statusElement) {
        statusElement.innerHTML = '<div class="alert alert-info">Processing keywords, please wait...</div>';
      }
      
      const progressElement = document.getElementById('processingProgress');
      const progressBar = progressElement.querySelector('.progress-bar');
      const progressText = document.getElementById('progressText');
      
      // Initialize workflow progress
      progressElement.classList.remove('d-none');
      progressBar.style.width = '0%';
      progressBar.setAttribute('aria-valuenow', 0);
      progressText.textContent = 'Initializing content generation pipeline...';
      
      // Initialize simple counters
      document.getElementById('progressCount').textContent = `0 / ${selectedKeywords.length}`;
      document.getElementById('progressPercentage').textContent = '0%';
      document.getElementById('successCount').textContent = '0';
      document.getElementById('failedCount').textContent = '0';
      document.getElementById('remainingCount').textContent = selectedKeywords.length;
      document.getElementById('elapsedTime').textContent = '00:00';
      document.getElementById('currentKeyword').textContent = '';
      
      // Store content option for restoration after refresh
      localStorage.setItem('currentContentOption', contentOption);
      localStorage.setItem('processingStartTime', Date.now().toString());
      
      // Reset workflow steps based on selected content option
      resetWorkflowSteps(contentOption);
      
      processKeywordsInSequence(selectedKeywords, contentOption);
    }
    });
  } else {
    console.warn('‚ö†Ô∏è processSelectedBtn element not found!');
  }
  
  // MODIFIED BATCH PROCESSING: Add delays between requests to avoid Discord spam detection
  async function processKeywordsInSequence(keywordIds, contentOption) {
    const total = keywordIds.length;
    const results = [];
    const startTime = Date.now();

    // Initialize batch results tracking
    window.batchResults = {
      timestamp: new Date().toISOString(),
      startTime: startTime,
      summary: {
        total: total,
        successful: 0,
        withRetry: 0,
        failed: 0
      },
      successful: [],
      withRetry: [],
      failed: [],
      duration: null,
      keywordAttempts: {} // Track retry attempts per keyword
    };

    // Clear cancellation flag when starting new processing
    window.processingCancelled = false;
    window.countedKeywords = new Set(); // Clear double-counting tracker
    console.log('üöÄ Cleared cancellation flag and counter tracking, starting new processing');
    console.log('üìä Initialized batch results tracking');
    
    const progressBar = document.querySelector('.progress-bar');
    const progressText = document.getElementById('progressText');
    
    // Start elapsed time counter
    window.processingTimeInterval = setInterval(() => {
      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      document.getElementById('elapsedTime').textContent = 
        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }, 1000);
    
    console.log(`üöÄ Starting BATCH processing for ${total} keywords (all at once with PinClicks batch mode)`);

    // Set initial workflow state
    showWorkflowProgress('recipe', `Processing ${total} keywords`);

    // Update simple progress
    const progressPercent = Math.round((1 / total) * 50); // Only show 50% during initialization
    progressBar.style.width = `${progressPercent}%`;
    progressBar.setAttribute('aria-valuenow', progressPercent);
    document.getElementById('progressPercentage').textContent = `${progressPercent}%`;

    // Update UI to processing immediately for all keywords
    keywordIds.forEach(id => {
      updateKeywordRowInUI(id, { status: 'processing' });
    });

    // Start processing request for ALL keywords at once (batch mode)
    fetch('/api/keywords/process-selected', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cache-Control': 'no-cache',
        'Pragma': 'no-cache'
      },
      body: JSON.stringify({
        keywordIds: keywordIds, // Send ALL keyword IDs
        contentOption: contentOption,
        ...getSelectedTemplate()
      })
    })
    .then(response => {
      if (response.ok) {
        console.log(`‚úÖ Processing started for all ${total} keywords`);
      } else {
        console.error(`‚ùå Failed to start processing keywords`);
        keywordIds.forEach(id => {
          updateKeywordRowInUI(id, { status: 'failed', message: 'Server error' });
        });
      }
    })
    .catch(error => {
      console.log(`‚ö†Ô∏è Network timeout, monitoring status...`);
      // Even on timeout, we'll monitor via polling
    });
    
    // Update progress to show all requests started
    progressBar.style.width = '75%';
    progressBar.setAttribute('aria-valuenow', 75);
    progressText.textContent = `All ${total} keywords sent to processing pipeline (with spam protection)!`;
    
    // Start polling all keywords for status updates (use original working system)
    console.log('üîÑ Starting batch status monitoring...');
    startBatchStatusMonitoringWithProgressCounters(keywordIds, contentOption);
    
    // Update status after workflow simulations
    setTimeout(() => {
      const progressText = document.getElementById('progressText');
      if (progressText) {
        progressText.textContent = `Monitoring content generation progress...`;
      }
    }, 2000);
  }
  
  // Auto-start next keyword for sequential processing
  function startNextKeywordIfAvailable(keywordIds, completedKeywords, startedKeywords, contentOption) {
    console.log(`üîç Checking for next keyword to start. Completed: ${completedKeywords.size}/${keywordIds.length}, Started: ${startedKeywords.size}/${keywordIds.length}`);
    console.log(`Completed keywords:`, Array.from(completedKeywords));
    console.log(`Started keywords:`, Array.from(startedKeywords));
    console.log(`All keywords:`, keywordIds);

    // Check for cancellation flag
    if (window.processingCancelled) {
      console.log('üõë Processing cancelled, not starting next keyword');
      return;
    }

    // Find the first keyword that hasn't been started yet
    const nextKeywordId = keywordIds.find(id => !startedKeywords.has(id));

    if (nextKeywordId) {
      const keywordIndex = keywordIds.indexOf(nextKeywordId) + 1;
      const total = keywordIds.length;

      console.log(`üöÄ Auto-starting next keyword ${keywordIndex}/${total}: ${nextKeywordId}`);

      // Mark this keyword as started IMMEDIATELY to prevent race conditions
      startedKeywords.add(nextKeywordId);

      // Update UI to processing
      updateKeywordRowInUI(nextKeywordId, { status: 'processing' });

      // Set workflow state
      showWorkflowProgress('recipe', `Keyword ${keywordIndex}/${total}`);

      // Update current keyword display
      document.getElementById('currentKeyword').textContent = `Processing keyword ${keywordIndex} of ${total}`;

      // Start processing with better error handling
      fetch('/api/keywords/process-selected', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache'
        },
        body: JSON.stringify({
          keywordIds: [nextKeywordId],
          contentOption: contentOption,
          ...getSelectedTemplate()
        })
      })
      .then(response => {
        if (response.ok) {
          console.log(`‚úÖ Next keyword processing started: ${nextKeywordId}`);
          return response.json();
        } else {
          console.error(`‚ùå Failed to start next keyword: ${nextKeywordId} - Status: ${response.status}`);
          // Remove from started set since it failed to start
          startedKeywords.delete(nextKeywordId);
          updateKeywordRowInUI(nextKeywordId, { status: 'failed', message: 'Server error' });
          updateProgressCounters('failed', nextKeywordId);
          // Mark as completed (failed) so we can move on
          completedKeywords.add(nextKeywordId);
          // Try to start the next keyword after this failure
          setTimeout(() => startNextKeywordIfAvailable(keywordIds, completedKeywords, window.startedKeywords, contentOption), 3000);
          throw new Error(`HTTP ${response.status}`);
        }
      })
      .then(data => {
        console.log(`üìä Server response for keyword ${nextKeywordId}:`, data);
      })
      .catch(error => {
        console.error(`‚ùå Error starting next keyword: ${nextKeywordId}`, error);
        // If keyword wasn't already handled above, handle it here
        if (startedKeywords.has(nextKeywordId) && !completedKeywords.has(nextKeywordId)) {
          startedKeywords.delete(nextKeywordId);
          updateKeywordRowInUI(nextKeywordId, { status: 'failed', message: 'Network error' });
          updateProgressCounters('failed', nextKeywordId);
          completedKeywords.add(nextKeywordId);
          // Try to start the next keyword after this failure
          setTimeout(() => startNextKeywordIfAvailable(keywordIds, completedKeywords, window.startedKeywords, contentOption), 3000);
        }
      });
    } else {
      console.log(`‚úÖ No more keywords to start. All ${keywordIds.length} keywords have been queued.`);

      // Check if all are also completed
      if (completedKeywords.size === keywordIds.length) {
        console.log(`üéâ All ${keywordIds.length} keywords completed!`);
      } else {
        console.log(`‚è≥ Waiting for ${keywordIds.length - completedKeywords.size} keywords to complete...`);
      }
    }
  }

  // Track keyword result for batch report
  function trackKeywordResult(keywordId, status, data) {
    if (!window.batchResults) return;

    // Get keyword name from data, or try from the table row, or use ID as fallback
    let keywordName = data.keyword || data.keywordName;

    if (!keywordName) {
      const keywordRow = document.querySelector(`tr[data-keyword-id="${keywordId}"]`);
      keywordName = keywordRow ? keywordRow.querySelector('td:first-child')?.textContent.trim() : keywordId;
    }

    // Enhanced logging - show all data fields received
    console.log(`\nüìä [BATCH RESULTS] Processing result for "${keywordName}"`);
    console.log(`   Status: ${status}`);
    console.log(`   Data keys:`, Object.keys(data));
    console.log(`   Has pinclicksTitles: ${!!data.pinclicksTitles}`);
    console.log(`   Has pinclicksDescriptions: ${!!data.pinclicksDescriptions}`);

    // Safely parse titles and descriptions with enhanced logging
    let titlesCount = null;
    let titlesData = null;
    let descriptionsCount = null;
    let descriptionsData = null;
    let overlaysCount = null;
    let overlaysData = null;

    try {
      if (data.pinclicksTitles) {
        console.log(`   Raw pinclicksTitles type: ${typeof data.pinclicksTitles}`);
        console.log(`   Raw pinclicksTitles preview: ${JSON.stringify(data.pinclicksTitles).substring(0, 100)}...`);

        const titles = typeof data.pinclicksTitles === 'string' ? JSON.parse(data.pinclicksTitles) : data.pinclicksTitles;
        titlesData = titles;
        titlesCount = Array.isArray(titles) ? titles.filter(t => t).length : null;

        console.log(`   ‚úÖ Parsed ${titlesCount} titles`);
        if (titlesCount > 0 && titles[0]) {
          console.log(`   Sample title: "${titles.find(t => t)?.substring(0, 60)}..."`);
        }
      } else {
        console.log(`   ‚ö†Ô∏è No pinclicksTitles data in response`);
      }
    } catch (e) {
      console.error(`   ‚ùå Failed to parse pinclicksTitles:`, e);
    }

    try {
      if (data.pinclicksDescriptions) {
        console.log(`   Raw pinclicksDescriptions type: ${typeof data.pinclicksDescriptions}`);
        console.log(`   Raw pinclicksDescriptions preview: ${JSON.stringify(data.pinclicksDescriptions).substring(0, 100)}...`);

        const descriptions = typeof data.pinclicksDescriptions === 'string' ? JSON.parse(data.pinclicksDescriptions) : data.pinclicksDescriptions;
        descriptionsData = descriptions;
        descriptionsCount = Array.isArray(descriptions) ? descriptions.filter(d => d).length : null;

        console.log(`   ‚úÖ Parsed ${descriptionsCount} descriptions`);
        if (descriptionsCount > 0 && descriptions[0]) {
          console.log(`   Sample description: "${descriptions.find(d => d)?.substring(0, 60)}..."`);
        }
      } else {
        console.log(`   ‚ö†Ô∏è No pinclicksDescriptions data in response`);
      }
    } catch (e) {
      console.error(`   ‚ùå Failed to parse pinclicksDescriptions:`, e);
    }

    try {
      if (data.pinclicksOverlays) {
        const overlays = typeof data.pinclicksOverlays === 'string' ? JSON.parse(data.pinclicksOverlays) : data.pinclicksOverlays;
        overlaysData = overlays;
        overlaysCount = Array.isArray(overlays) ? overlays.filter(o => o).length : null;
        console.log(`   ‚úÖ Parsed ${overlaysCount} overlays`);
      }
    } catch (e) {
      console.error(`   ‚ùå Failed to parse pinclicksOverlays:`, e);
    }

    const resultData = {
      keyword: keywordName,
      keywordId: keywordId,
      attempts: window.batchResults.keywordAttempts[keywordId] || 1,
      titles: titlesCount,
      descriptions: descriptionsCount,
      overlays: overlaysCount,
      titlesData: titlesData,
      descriptionsData: descriptionsData,
      overlaysData: overlaysData,
      error: data.error || data.message || null,
      source: data.source || 'unknown', // Track whether ChatGPT or OpenAI fallback was used
      // Store timestamp for tracking
      timestamp: new Date().toISOString(),
      // Store full data for debugging
      rawDataKeys: Object.keys(data)
    };

    if (status === 'success') {
      // Check if this was a retry success (attempts > 1)
      if (resultData.attempts > 1) {
        window.batchResults.withRetry.push(resultData);
        window.batchResults.summary.withRetry++;
      } else {
        window.batchResults.successful.push(resultData);
        window.batchResults.summary.successful++;
      }

      console.log(`   ‚úÖ Tracked as ${resultData.attempts > 1 ? 'WITH RETRY' : 'SUCCESSFUL'}`);
    } else if (status === 'failed') {
      window.batchResults.failed.push(resultData);
      window.batchResults.summary.failed++;
      console.log(`   ‚ùå Tracked as FAILED`);
      if (resultData.error) {
        console.log(`   Error: ${resultData.error}`);
      }
    }

    console.log(`üìä [BATCH RESULTS] Summary: ${window.batchResults.summary.successful} successful, ${window.batchResults.summary.withRetry} with retry, ${window.batchResults.summary.failed} failed\n`);
  }

  // Finalize batch results and redirect to results page
  async function finalizeBatchResultsAndRedirect() {
    if (!window.batchResults) {
      console.warn('‚ö†Ô∏è No batch results to finalize');
      return;
    }

    const endTime = Date.now();
    const durationMs = endTime - window.batchResults.startTime;
    const minutes = Math.floor(durationMs / 60000);
    const seconds = Math.floor((durationMs % 60000) / 1000);
    window.batchResults.duration = `${minutes}m ${seconds}s`;

    console.log('üìä [BATCH RESULTS] Finalizing results...');
    console.log(`   Total: ${window.batchResults.summary.total}`);
    console.log(`   ‚úÖ Successful: ${window.batchResults.summary.successful}`);
    console.log(`   üîÑ With Retry: ${window.batchResults.summary.withRetry}`);
    console.log(`   ‚ùå Failed: ${window.batchResults.summary.failed}`);
    console.log(`   ‚è±Ô∏è Duration: ${window.batchResults.duration}`);

    try {
      // Save results to session via API
      const response = await fetch('/api/batch-results/save', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          results: window.batchResults
        })
      });

      if (response.ok) {
        console.log('‚úÖ Batch results saved, redirecting to results page...');
        // Add a small delay so user can see the success message
        setTimeout(() => {
          window.location.href = '/batch-results';
        }, 2000);
      } else {
        console.error('‚ùå Failed to save batch results');
        showStatus('error', 'Failed to save batch results. Check console for details.');
      }
    } catch (error) {
      console.error('‚ùå Error saving batch results:', error);
      showStatus('error', 'Error saving batch results: ' + error.message);
    }
  }

  // Enhanced batch monitoring that updates the progress counters correctly
  function startBatchStatusMonitoringWithProgressCounters(keywordIds, contentOption) {
    // Clear any existing monitoring interval first
    if (window.batchMonitoringInterval) {
      clearInterval(window.batchMonitoringInterval);
      console.log('üîÑ Cleared existing monitoring interval');
    }

    const completedKeywords = new Set();
    // Store startedKeywords globally so other functions can access it
    window.startedKeywords = new Set();
    // Mark first keyword as started since we start it in processKeywordsInSequence
    window.startedKeywords.add(keywordIds[0]);
    let checkCount = 0;

    // DYNAMIC TIMEOUT: Calculate based on number of keywords
    // Each keyword can take up to 15 minutes (PinClicks + content + image generation)
    // Add buffer: 15 minutes per keyword + 30 minutes base
    const estimatedMinutesPerKeyword = 15;
    const baseMinutes = 30;
    const totalMinutes = (keywordIds.length * estimatedMinutesPerKeyword) + baseMinutes;
    let maxChecks = Math.max(360, Math.floor((totalMinutes * 60) / 10)); // At least 60 minutes, check every 10s (use let for extension)

    console.log(`‚è±Ô∏è Batch monitoring timeout: ${totalMinutes} minutes (${maxChecks} checks)`);
    console.log(`   Processing ${keywordIds.length} keywords`);
    console.log(`   Estimated: ${estimatedMinutesPerKeyword} min/keyword + ${baseMinutes} min base`)

    // Store the interval globally so we can stop it
    window.batchMonitoringInterval = setInterval(async () => {
      checkCount++;
      console.log(`üì° Batch status check ${checkCount}/${maxChecks} - ${completedKeywords.size}/${keywordIds.length} completed, ${window.startedKeywords.size}/${keywordIds.length} started`);

      // Check for cancellation flag
      if (window.processingCancelled) {
        console.log('üõë Processing cancelled, stopping monitoring');
        clearInterval(window.batchMonitoringInterval);
        window.batchMonitoringInterval = null;
        return;
      }

      // Check if we should start the next keyword (more aggressive checking)
      if (window.startedKeywords.size < keywordIds.length &&
          window.startedKeywords.size === completedKeywords.size) {
        console.log('üöÄ Detected opportunity to start next keyword - all started keywords are completed');
        startNextKeywordIfAvailable(keywordIds, completedKeywords, window.startedKeywords, contentOption);
      }

      for (const keywordId of keywordIds) {
        if (completedKeywords.has(keywordId)) continue; // Skip already completed

        try {
          const response = await fetch(`/api/keywords/status/${keywordId}`, {
            method: 'GET',
            headers: { 'Cache-Control': 'no-cache' }
          });

          if (response.ok) {
            const data = await response.json();

            if (data.status === 'processed') {
              if (!completedKeywords.has(keywordId)) {
                completedKeywords.add(keywordId);
                updateKeywordRowInUI(keywordId, data);
                updateWorkflowBasedOnStatus(keywordId, 'processed', data);
                updateProgressCounters('processed', keywordId); // UPDATE COUNTERS WITH ID!

                // Track result for batch report
                trackKeywordResult(keywordId, 'success', data);

                // Start image monitoring for this keyword
                if (data.recipeId) {
                  setTimeout(() => startSmartImageMonitoring(data.recipeId, keywordId), 10000);
                }

                console.log(`‚úÖ Keyword ${keywordId} completed successfully, starting next keyword...`);
                // AUTO-START NEXT KEYWORD (sequential processing)
                setTimeout(() => {
                  startNextKeywordIfAvailable(keywordIds, completedKeywords, window.startedKeywords, contentOption);
                }, 2000); // Small delay before starting next
              }

            } else if (data.status === 'failed') {
              if (!completedKeywords.has(keywordId)) {
                completedKeywords.add(keywordId);
                updateKeywordRowInUI(keywordId, data);
                updateWorkflowBasedOnStatus(keywordId, 'failed', data);
                updateProgressCounters('failed', keywordId); // UPDATE COUNTERS WITH ID!

                // Track result for batch report
                trackKeywordResult(keywordId, 'failed', data);

                console.log(`‚ùå Keyword ${keywordId} failed, starting next keyword...`);
                // AUTO-START NEXT KEYWORD (sequential processing)
                setTimeout(() => {
                  startNextKeywordIfAvailable(keywordIds, completedKeywords, window.startedKeywords, contentOption);
                }, 2000); // Small delay before starting next
              }
            } else if (data.status === 'processing') {
              // Update workflow for ongoing processing
              updateWorkflowBasedOnStatus(keywordId, 'processing', data);
            }
            // If still processing, keep checking
          }
        } catch (error) {
          console.error(`‚ö†Ô∏è Error checking status for keyword ${keywordId}:`, error);
          // Continue checking on errors
        }
      }

      // Stop when all completed or max checks reached
      if (completedKeywords.size >= keywordIds.length) {
        console.log(`üéâ All ${keywordIds.length} keywords completed!`);
        clearInterval(window.batchMonitoringInterval);
        window.batchMonitoringInterval = null;
        clearInterval(window.processingTimeInterval);

        const successCount = parseInt(document.getElementById('successCount').textContent) || 0;
        const failedCount = parseInt(document.getElementById('failedCount').textContent) || 0;

        // Final progress update
        const progressBar = document.querySelector('.progress-bar');
        progressBar.style.width = '100%';
        progressBar.setAttribute('aria-valuenow', 100);

        if (failedCount === 0) {
          progressBar.style.backgroundImage = 'linear-gradient(90deg, var(--accent-teal) 0%, #4aecbf 100%)';
          showStatus('success', `‚úÖ All ${keywordIds.length} keywords completed successfully!`);
        } else {
          progressBar.style.backgroundImage = 'linear-gradient(90deg, var(--accent-amber) 0%, #ffcf9c 100%)';
          showStatus('success', `‚úÖ Batch completed: ${successCount} successful, ${failedCount} failed.`);
        }

        // Finalize batch results and redirect to results page
        finalizeBatchResultsAndRedirect();
      } else if (checkCount >= maxChecks) {
        console.warn(`‚è∞ Maximum check count reached (${maxChecks}), checking if still processing...`);

        // Check if any keywords are actively processing before giving up
        let stillProcessing = false;
        for (const keywordId of keywordIds) {
          if (completedKeywords.has(keywordId)) continue;

          try {
            const response = await fetch(`/api/keywords/status/${keywordId}`, {
              method: 'GET',
              headers: { 'Cache-Control': 'no-cache' }
            });

            if (response.ok) {
              const data = await response.json();
              if (data.status === 'processing') {
                stillProcessing = true;
                console.log(`‚è≥ Keyword ${keywordId} is still processing, extending timeout...`);
                break;
              }
            }
          } catch (error) {
            console.error(`Error checking final status for ${keywordId}:`, error);
          }
        }

        if (stillProcessing) {
          // Extend timeout by 30 minutes if keywords are still processing
          const extensionChecks = 180; // 30 more minutes
          maxChecks += extensionChecks;
          console.log(`‚è±Ô∏è Extended timeout by ${extensionChecks} checks (30 minutes). New limit: ${maxChecks}`);
          showStatus('info', `‚è≥ Keywords still processing, extended timeout by 30 minutes...`);
        } else {
          // Really stop now
          clearInterval(window.batchMonitoringInterval);
          window.batchMonitoringInterval = null;
          clearInterval(window.processingTimeInterval);

          const remaining = keywordIds.length - completedKeywords.size;
          const successCount = parseInt(document.getElementById('successCount').textContent) || 0;
          const failedCount = parseInt(document.getElementById('failedCount').textContent) || 0;

          showStatus('warning', `${completedKeywords.size}/${keywordIds.length} completed. ${remaining} keywords may still be processing - refresh to check status.`);
        }
      }
    }, 10000); // Check every 10 seconds
  }
  
  // Monitor multiple keywords during batch processing
  function startBatchStatusMonitoring(keywordIds) {
    // Don't start if enhanced monitoring is already running
    if (window.batchMonitoringInterval) {
      console.log('‚ö†Ô∏è Enhanced monitoring already running, skipping old monitoring function');
      return;
    }
    
    const completedKeywords = new Set();
    let checkCount = 0;
    const maxChecks = 120; // Check for up to 20 minutes (120 * 10s)
    
    // Store the interval globally so we can stop it
    window.batchMonitoringInterval = setInterval(async () => {
      checkCount++;
      console.log(`üì° Batch status check ${checkCount}/${maxChecks} - ${completedKeywords.size}/${keywordIds.length} completed`);
      
      for (const keywordId of keywordIds) {
        if (completedKeywords.has(keywordId)) continue; // Skip already completed
        
        try {
          const response = await fetch(`/api/keywords/status/${keywordId}`, {
            method: 'GET',
            headers: { 'Cache-Control': 'no-cache' }
          });
          
          if (response.ok) {
            const data = await response.json();
            
            if (data.status === 'processed') {
              completedKeywords.add(keywordId);
              updateKeywordRowInUI(keywordId, data);
              updateWorkflowBasedOnStatus(keywordId, 'processed', data);
              
              // Start image monitoring for this keyword
              if (data.recipeId) {
                setTimeout(() => startSmartImageMonitoring(data.recipeId, keywordId), 10000);
              }
              
            } else if (data.status === 'failed') {
              completedKeywords.add(keywordId);
              updateKeywordRowInUI(keywordId, data);
              updateWorkflowBasedOnStatus(keywordId, 'failed', data);
            } else if (data.status === 'processing') {
              // Update workflow for ongoing processing
              updateWorkflowBasedOnStatus(keywordId, 'processing', data);
            }
            // If still processing, keep checking
          }
        } catch (error) {
          // Continue checking on errors
        }
      }
      
      // Stop when all completed or max checks reached
      if (completedKeywords.size >= keywordIds.length || checkCount >= maxChecks) {
        clearInterval(window.batchMonitoringInterval);
        window.batchMonitoringInterval = null;
        const remaining = keywordIds.length - completedKeywords.size;
        
        if (remaining > 0) {
          showStatus('warning', `${completedKeywords.size}/${keywordIds.length} completed. ${remaining} still processing - refresh to check status.`);
        } else {
          showStatus('success', `All ${keywordIds.length} keywords completed successfully!`);
        }
      }
    }, 10000); // Check every 10 seconds
  }

  // Initialize tracking for counted keywords to prevent double counting
  window.countedKeywords = window.countedKeywords || new Set();
  
  // Simplified progress counter updates with comprehensive debugging
  function updateProgressCounters(status, keywordId = null) {
    console.log(`üî¢ updateProgressCounters called with status: ${status}, keywordId: ${keywordId}`);
    console.log(`üî¢ Call stack:`, new Error().stack.split('\n')[1].trim());
    
    const successElement = document.getElementById('successCount');
    const failedElement = document.getElementById('failedCount');
    const remainingElement = document.getElementById('remainingCount');
    const progressCountElement = document.getElementById('progressCount');
    
    if (!successElement || !failedElement) {
      console.log(`üî¢ Missing elements, returning`);
      return;
    }
    
    let currentSuccess = parseInt(successElement.textContent) || 0;
    let currentFailed = parseInt(failedElement.textContent) || 0;
    
    console.log(`üî¢ Before update: Success=${currentSuccess}, Failed=${currentFailed}`);
    
    // Prevent double counting if keywordId is provided
    if (keywordId) {
      const countKey = `${keywordId}-${status}`;
      if (window.countedKeywords.has(countKey)) {
        console.log(`‚ö†Ô∏è Preventing double count for keyword ${keywordId} status ${status}`);
        return;
      }
      window.countedKeywords.add(countKey);
      console.log(`üìä First time counting keyword ${keywordId} as ${status}`);
    }
    
    if (status === 'processed') {
      currentSuccess++;
      successElement.textContent = currentSuccess;
      console.log(`üî¢ After processed update: Success now = ${currentSuccess}`);
      // Mark completed steps as completed (get visible steps only)
      const visibleSteps = document.querySelectorAll('.workflow-step');
      visibleSteps.forEach(stepElement => {
        if (stepElement.closest('.col').style.display !== 'none') {
          const stepId = stepElement.id.replace('step-', '');
          updateWorkflowStep(stepId, 'completed');
        }
      });
    } else if (status === 'failed') {
      currentFailed++;
      failedElement.textContent = currentFailed;
      console.log(`üî¢ After failed update: Failed now = ${currentFailed}`);
      // Mark first visible step as failed
      const visibleSteps = document.querySelectorAll('.workflow-step');
      for (const stepElement of visibleSteps) {
        if (stepElement.closest('.col').style.display !== 'none') {
          const stepId = stepElement.id.replace('step-', '');
          updateWorkflowStep(stepId, 'failed');
          break; // Only mark the first step as failed
        }
      }
    }
    
    // Update simple counters
    const totalProcessed = currentSuccess + currentFailed;
    const totalText = progressCountElement.textContent;
    const total = parseInt(totalText.split(' / ')[1]) || 0;
    const remaining = Math.max(0, total - totalProcessed);
    
    remainingElement.textContent = remaining;
    progressCountElement.textContent = `${totalProcessed} / ${total}`;
    
    // Update progress bar
    if (total > 0) {
      const percentage = Math.round((totalProcessed / total) * 100);
      document.getElementById('progressPercentage').textContent = `${percentage}%`;
      
      const progressBar = document.querySelector('.progress-bar');
      if (progressBar) {
        progressBar.style.width = `${percentage}%`;
        progressBar.setAttribute('aria-valuenow', percentage);
      }
      
      // Check completion
      if (totalProcessed >= total) {
        completeProcessing(currentSuccess, currentFailed);
      }
    }
  }
  
  function completeProcessing(successCount, failedCount) {
    // Clear timer
    if (window.processingTimeInterval) {
      clearInterval(window.processingTimeInterval);
      window.processingTimeInterval = null;
    }
    
    // Clear localStorage since processing is complete
    localStorage.removeItem('currentContentOption');
    localStorage.removeItem('processingStartTime');
    
    // Update status
    document.getElementById('progressText').textContent = 
      `Processing completed! ${successCount} successful, ${failedCount} failed.`;
    document.getElementById('currentKeyword').textContent = '';
    
    // Change progress bar style
    const progressBar = document.querySelector('.progress-bar');
    if (progressBar) {
      progressBar.classList.remove('progress-bar-animated');
      if (failedCount === 0) {
        progressBar.style.backgroundImage = 'linear-gradient(90deg, #28a745 0%, #34ce57 100%)';
      } else {
        progressBar.style.backgroundImage = 'linear-gradient(90deg, #ffc107 0%, #ffdb4d 100%)';
      }
    }
    
    // Don't auto-hide during sequential processing - let user manually close or navigate away
    // Sequential processing keeps progress visible for better user experience
  }

  // NEW SIMPLE UPDATE FUNCTION
  function updateKeywordRowInUI(keywordId, result) {
    try {
      const card = document.querySelector(`.keyword-card[data-id="${keywordId}"]`);
      if (!card) {
        console.warn(`Card not found for keyword: ${keywordId}`);
        return;
      }
      
      console.log(`üîÑ Updating UI for keyword ${keywordId}:`, result.status);
      
      // Progress counters are updated by the monitoring logic to prevent double-counting
      // Do not update counters here as it causes duplicate counts
      
      // Update content status badge
      const contentBadge = card.querySelector('[data-badge="content"]');
      if (contentBadge) {
        if (result.status === 'processing') {
          contentBadge.className = 'badge bg-info me-2';
          contentBadge.textContent = 'üîÑ PROCESSING';
        } else if (result.status === 'already_processing') {
          contentBadge.className = 'badge bg-info me-2';
          contentBadge.textContent = '‚è≥ PROCESSING';
          return; // Don't update anything else
        } else if (result.status === 'processed') {
          contentBadge.className = 'badge bg-success me-2';
          contentBadge.textContent = '‚úÖ COMPLETED';
          
          // Update image badge to show pending (monitoring will start in 60s)
          const imageBadge = card.querySelector('[data-badge="image"]');
          if (imageBadge && result.recipeId) {
            imageBadge.className = 'badge bg-secondary me-2';
            imageBadge.textContent = 'üñºÔ∏è PENDING';
            imageBadge.setAttribute('data-recipe-id', result.recipeId);
          }
          
          // Update action buttons
          const actionsDiv = card.querySelector('.btn-group-vertical');
          if (actionsDiv && result.recipeId) {
            actionsDiv.innerHTML = `
              <a href="/recipe/${result.recipeId}" class="btn btn-sm btn-primary mb-1">
                <i class="bi bi-eye"></i> View
              </a>
              <button type="button" class="btn btn-sm btn-info regenerate-image-btn mb-1" data-recipe-id="${result.recipeId}">
                <i class="bi bi-arrow-repeat"></i> Regenerate
              </button>
            `;

            const newRegenerateBtn = actionsDiv.querySelector('.regenerate-image-btn');
            if (newRegenerateBtn) {
              newRegenerateBtn.addEventListener('click', async function() {
                const recipeId = this.getAttribute('data-recipe-id');
                if (!recipeId) {
                  showStatus('error', 'Recipe ID not found for regeneration');
                  return;
                }

                if (confirm('Are you sure you want to regenerate the image for this recipe?')) {
                  try {
                    this.disabled = true;
                    const originalText = this.innerHTML;
                    this.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Regenerating...';

                    const response = await fetch(`/midjourney/api/generate/${recipeId}`, {
                      method: 'POST',
                      headers: {
                        'Content-Type': 'application/json'
                      }
                    });

                    const data = await response.json();

                    if (data.success) {
                      showStatus('success', 'Image generation started successfully');
                      setTimeout(() => {
                        this.disabled = false;
                        this.innerHTML = originalText;
                      }, 3000);
                    } else {
                      showStatus('error', data.error || 'Failed to regenerate image');
                      this.disabled = false;
                      this.innerHTML = originalText;
                    }
                  } catch (error) {
                    console.error('Error regenerating image:', error);
                    showStatus('error', error.message || 'An unknown error occurred');
                    this.disabled = false;
                    this.innerHTML = originalText;
                  }
                }
              });
            }
          }
          
          // Disable checkbox
          const checkbox = card.querySelector('.keyword-checkbox');
          if (checkbox) {
            checkbox.disabled = true;
            checkbox.checked = false;
          }
          
        } else if (result.status === 'failed') {
          contentBadge.className = 'badge bg-danger me-2';
          contentBadge.textContent = '‚ùå FAILED';
        } else if (result.status === 'pending') {
          contentBadge.className = 'badge bg-warning me-2';
          contentBadge.textContent = 'üìù PENDING';
        }
      }
      
      // Update card data attribute
      card.setAttribute('data-status', result.status);
      
      console.log(`‚úÖ UI updated for keyword ${keywordId}`); 
      
      card.style.backgroundColor = '#d4edda';
      setTimeout(() => {
        card.style.backgroundColor = '';
      }, 2000);
      
    } catch (error) {
      console.error(`Error updating UI for keyword ${keywordId}:`, error);
    }
  }
  
  // Process next pending keywords
  safeAddClickHandler('processNextBtn', function() {
    const optionElement = document.querySelector('input[name="contentOption"]:checked');
    const contentOption = optionElement ? optionElement.value : 'facebook';
    
    const pendingKeywords = Array.from(document.querySelectorAll('.keyword-card[data-status="pending"]'))
      .map(card => card.getAttribute('data-id'))
      .slice(0, 5);
    
    if (pendingKeywords.length === 0) {
      alert('No pending keywords found.');
      return;
    }
    
    if (confirm(`Process ${pendingKeywords.length} pending keywords with ${contentOption} option?`)) {
      const statusElement = document.getElementById('statusMessage');
      if (statusElement) {
        statusElement.innerHTML = '<div class="alert alert-info">Processing keywords, please wait...</div>';
      }
      
      const progressElement = document.getElementById('processingProgress');
      const progressBar = progressElement.querySelector('.progress-bar');
      const progressText = document.getElementById('progressText');
      
      progressElement.classList.remove('d-none');
      progressBar.style.width = '0%';
      progressBar.setAttribute('aria-valuenow', 0);
      progressText.textContent = 'üîÑ Preparing batch processing - Analyzing keywords and content options...';
      
      processKeywordsInSequence(pendingKeywords, contentOption);
    }
  });
  
  // Process buttons in the keywords list
  document.querySelectorAll('.process-btn').forEach(button => {
    button.addEventListener('click', function() {
      const keywordId = this.getAttribute('data-id');
      const optionElement = document.querySelector('input[name="contentOption"]:checked');
      const contentOption = optionElement ? optionElement.value : 'facebook';
      
      if (confirm(`Process this keyword with ${contentOption} option?`)) {
        const statusElement = document.getElementById('statusMessage');
        if (statusElement) {
          statusElement.innerHTML = '<div class="alert alert-info">Processing keyword, please wait...</div>';
        }
        
        // IMMEDIATELY update UI to show processing status
        updateKeywordRowInUI(keywordId, { status: 'processing' });
        
        // ASYNC PROCESSING: Start request but don't wait for full response
        console.log('üöÄ Starting async processing for keyword:', keywordId);
        showStatus('info', 'Processing started, monitoring progress...');
        
        // Start the processing request (don't wait for response)
        fetch('/api/keywords/process-selected', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            keywordIds: [keywordId],
            contentOption: contentOption,
            ...getSelectedTemplate()
          })
        })
        .then(response => {
          if (response.ok) {
            console.log('‚úÖ Processing request accepted by server');
            // Start polling for status updates
            startKeywordStatusPolling(keywordId);
          } else {
            console.error('‚ùå Server rejected processing request');
            updateKeywordRowInUI(keywordId, { status: 'failed', message: 'Server error' });
          }
        })
        .catch(error => {
          console.log('‚ö†Ô∏è Network timeout detected, starting polling anyway...');
          console.log('üì° Reason: Cloudways cuts off long requests, but processing continues on server');
          
          // The request probably started but timed out - start polling
          startKeywordStatusPolling(keywordId);
        });
      }
    });
  });
  
  // Retry buttons
  document.querySelectorAll('.retry-btn').forEach(button => {
    button.addEventListener('click', function() {
      const keywordId = this.getAttribute('data-id');
      const optionElement = document.querySelector('input[name="contentOption"]:checked');
      const contentOption = optionElement ? optionElement.value : 'facebook';
      
      if (confirm(`Retry processing this keyword with ${contentOption} option?`)) {
        const statusElement = document.getElementById('statusMessage');
        if (statusElement) {
          statusElement.innerHTML = '<div class="alert alert-info">Processing keyword, please wait...</div>';
        }
        
        // IMMEDIATELY update UI to show processing status
        updateKeywordRowInUI(keywordId, { status: 'processing' });
        
        // ASYNC PROCESSING: Start request but don't wait for full response
        console.log('üîÑ Starting async retry processing for keyword:', keywordId);
        showStatus('info', 'Retry processing started, monitoring progress...');
        
        // Start the processing request (don't wait for response)
        fetch('/api/keywords/process-selected', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            keywordIds: [keywordId],
            contentOption: contentOption,
            ...getSelectedTemplate()
          })
        })
        .then(response => {
          if (response.ok) {
            console.log('‚úÖ Retry processing request accepted by server');
            // Start polling for status updates
            startKeywordStatusPolling(keywordId);
          } else {
            console.error('‚ùå Server rejected retry processing request');
            updateKeywordRowInUI(keywordId, { status: 'failed', message: 'Server error' });
          }
        })
        .catch(error => {
          console.log('‚ö†Ô∏è Network timeout detected during retry, starting polling anyway...');
          
          // The request probably started but timed out - start polling
          startKeywordStatusPolling(keywordId);
        });
      }
    });
  });

  // Run Pinclicks automation button
  document.querySelectorAll('.run-pinclicks-btn').forEach(button => {
    button.addEventListener('click', async function() {
      const keywordId = this.getAttribute('data-id');
      const keywordText = this.getAttribute('data-keyword');

      if (!confirm(`Run Pinclicks automation for "${keywordText}"?\n\nThis will:\n1. Search pinclicks.com for this keyword\n2. Download annotated interests data\n3. Upload to ChatGPT for SEO analysis\n4. Store optimized Pinterest titles and descriptions\n\nThis may take 1-2 minutes.`)) {
        return;
      }

      // Disable button and show progress
      this.disabled = true;
      this.innerHTML = '<i class="bi bi-hourglass-split"></i> Running...';

      try {
        showStatus('info', `Running Pinclicks automation for "${keywordText}"...`);

        const response = await fetch(`/api/keywords/run-pinclicks/${keywordId}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          },
          credentials: 'same-origin'  // Include cookies for authentication
        });

        // Check if response is JSON before parsing
        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
          const text = await response.text();
          console.error('‚ùå Server returned non-JSON response:', text.substring(0, 200));
          throw new Error(`Server error: Expected JSON but got ${contentType || 'unknown type'}. Check server console for details.`);
        }

        const data = await response.json();

        if (data.success) {
          showStatus('success', `Pinclicks completed! Found ${data.data.titlesCount} titles, ${data.data.descriptionsCount} descriptions`);

          // Reload page after short delay to show updated keyword
          setTimeout(() => {
            window.location.reload();
          }, 2000);
        } else {
          throw new Error(data.message || 'Pinclicks automation failed');
        }

      } catch (error) {
        console.error('‚ùå Pinclicks automation error:', error);
        showStatus('error', `Pinclicks failed: ${error.message}`);

        // Re-enable button on error
        this.disabled = false;
        this.innerHTML = '<i class="bi bi-pinterest"></i> Pinclicks';
      }
    });
  });

  // Delete selected keywords
  const deleteSelectedBtn = document.getElementById('deleteSelectedBtn');
  if (deleteSelectedBtn) {
    deleteSelectedBtn.addEventListener('click', function() {
      const selectedKeywords = Array.from(document.querySelectorAll('.keyword-checkbox:checked'))
        .map(cb => cb.value);
        
      if (selectedKeywords.length === 0) {
        alert('No keywords selected for deletion.');
        return;
      }
      
      if (confirm(`Are you sure you want to delete ${selectedKeywords.length} selected keywords? This action cannot be undone.`)) {
        deleteKeywords(selectedKeywords);
      }
    });
  }
  
  // Delete buttons
  document.querySelectorAll('.delete-btn').forEach(button => {
    button.addEventListener('click', function() {
      const keywordId = this.getAttribute('data-id');
      
      if (confirm('Are you sure you want to delete this keyword? This action cannot be undone.')) {
        deleteKeywords([keywordId]);
      }
    });
  });
      
  // Helper function: Delete keywords
  async function deleteKeywords(keywordIds) {
    if (!keywordIds || keywordIds.length === 0) {
      showStatus('error', 'No keywords selected for deletion.');
      return;
    }
    
    try {
      const response = await fetch('/api/keywords/delete', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ keywordIds })
      });
      
      const data = await response.json();
      
      if (data.success) {
        showStatus('success', data.message || `Deleted ${data.count} keywords successfully`);
        
        setTimeout(() => {
          window.location.reload();
        }, 1500);
      } else {
        throw new Error(data.message || 'Failed to delete keywords');
      }
    } catch (error) {
      console.error('Error deleting keywords:', error);
      showStatus('error', error.message || 'An unknown error occurred');
    }
  }
  
  // Add event listeners for regenerate image buttons
  document.querySelectorAll('.regenerate-image-btn').forEach(button => {
    button.addEventListener('click', async function() {
      const recipeId = this.getAttribute('data-recipe-id');
      if (!recipeId) {
        showStatus('error', 'Recipe ID not found for regeneration');
        return;
      }

      if (confirm('Are you sure you want to regenerate the image for this recipe?')) {
        try {
          this.disabled = true;
          const originalText = this.innerHTML;
          this.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Regenerating...';

          const response = await fetch(`/midjourney/api/generate/${recipeId}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            }
          });

          const data = await response.json();

          if (data.success) {
            showStatus('success', 'Image generation started successfully');

            const statusCell = document.querySelector(`.image-status-cell[data-recipe-id="${recipeId}"]`);
            if (statusCell) {
              statusCell.innerHTML = `<span class="badge bg-warning">‚è≥ Pending</span>`;
            }

            setTimeout(() => {
              this.disabled = false;
              this.innerHTML = originalText;
            }, 3000);
          } else {
            showStatus('error', data.error || 'Failed to regenerate image');
            this.disabled = false;
            this.innerHTML = originalText;
          }
        } catch (error) {
          console.error('Error regenerating image:', error);
          showStatus('error', error.message || 'An unknown error occurred');
          this.disabled = false;
          this.innerHTML = originalText;
        }
      }
    });
  });

  // Add event listeners for regenerate Pinterest content buttons
  document.querySelectorAll('.regenerate-pinterest-btn').forEach(button => {
    button.addEventListener('click', async function() {
      const keywordId = this.getAttribute('data-keyword-id');
      const recipeId = this.getAttribute('data-recipe-id');
      const keyword = this.getAttribute('data-keyword');

      if (!keywordId || !recipeId) {
        showStatus('error', 'Keyword or Recipe ID not found for regeneration');
        return;
      }

      if (confirm(`Are you sure you want to regenerate Pinterest content for "${keyword}"?\n\nThis will delete existing Pinterest variations and create new ones.`)) {
        try {
          this.disabled = true;
          const originalText = this.innerHTML;
          this.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Regenerating...';

          const response = await fetch(`/api/regenerate-pinterest/${keywordId}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            }
          });

          const data = await response.json();

          if (data.success) {
            showStatus('success', `Pinterest content regenerated successfully! Created ${data.variationsCount} variations.`);

            // Reload the page after a short delay to show updated data
            setTimeout(() => {
              window.location.reload();
            }, 2000);
          } else {
            showStatus('error', data.error || 'Failed to regenerate Pinterest content');
            this.disabled = false;
            this.innerHTML = originalText;
          }
        } catch (error) {
          console.error('Error regenerating Pinterest content:', error);
          showStatus('error', error.message || 'An unknown error occurred');
          this.disabled = false;
          this.innerHTML = originalText;
        }
      }
    });
  });

  // Fix date formatting using date-fns
  function formatDates() {
    document.querySelectorAll('.date-cell').forEach(cell => {
      const dateStr = cell.getAttribute('data-date');
      if (dateStr) {
        try {
          const date = new Date(dateStr);
          const timeAgo = dateFns.formatDistanceToNow(date, { addSuffix: true });
          const formattedDate = dateFns.format(date, 'PPpp');
          
          cell.innerHTML = `<span title="${formattedDate}">${timeAgo}</span>`;
        } catch (error) {
          console.error('Error formatting date:', error);
          const date = new Date(dateStr);
          cell.innerHTML = date.toLocaleString();
        }
      }
    });
  }
    
  // Sort cards by date when needed
  function sortRowsByDate() {
    const container = document.querySelector('.keywords-vertical-list');
    if (!container) return;
    
    const cards = Array.from(container.querySelectorAll('.keyword-card[data-added]'));
    
    cards.sort((a, b) => {
      const dateA = new Date(a.getAttribute('data-added') || 0);
      const dateB = new Date(b.getAttribute('data-added') || 0);
      return dateB - dateA;
    });
    
    cards.forEach(card => container.appendChild(card));
  }
  
  // Excel file input handler for PinClicks
  const pinclicksExcelFileInput = document.getElementById('pinclicksExcelFile');
  if (pinclicksExcelFileInput) {
    pinclicksExcelFileInput.addEventListener('change', function(event) {
      const file = event.target.files[0];
      if (!file) {
        document.getElementById('pinclicksExcelPreview').classList.add('d-none');
        parsedPinclicksData = null;
        return;
      }
      
      const allowedTypes = [
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'application/vnd.ms-excel',
        'text/csv'
      ];
      
      if (!allowedTypes.includes(file.type) && !file.name.match(/\.(xlsx|xls|csv)$/i)) {
        showStatus('error', 'Please upload a valid Excel file (.xlsx, .xls) or CSV file.');
        return;
      }
      
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          let workbook;
          
          if (file.name.toLowerCase().endsWith('.csv')) {
            const csvData = e.target.result;
            
            // Parse CSV using the same robust logic as the Excel tab
            try {
              const lines = [];
              let currentLine = '';
              let insideQuotes = false;
              let quoteChar = null;
              
              for (let i = 0; i < csvData.length; i++) {
                const char = csvData[i];
                
                if ((char === '"' || char === "'") && !insideQuotes) {
                  insideQuotes = true;
                  quoteChar = char;
                  currentLine += char;
                } else if (char === quoteChar && insideQuotes) {
                  if (i + 1 < csvData.length && csvData[i + 1] === quoteChar) {
                    currentLine += char + char;
                    i++;
                  } else {
                    insideQuotes = false;
                    quoteChar = null;
                    currentLine += char;
                  }
                } else if (char === '\n' && !insideQuotes) {
                  if (currentLine.trim()) {
                    lines.push(currentLine.trim());
                  }
                  currentLine = '';
                } else {
                  currentLine += char;
                }
              }
              
              if (currentLine.trim()) {
                lines.push(currentLine.trim());
              }
              
              if (lines.length === 0) {
                throw new Error('No data found in CSV');
              }
              
              const headers = parseCSVLine(lines[0]);
              const rows = [];
              for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                if (line.trim()) {
                  const values = parseCSVLine(line);
                  const row = {};
                  headers.forEach((header, index) => {
                    row[header] = values[index] || '';
                  });
                  rows.push(row);
                }
              }
              
              parsedPinclicksData = {
                headers: headers,
                data: rows
              };
              
            } catch (csvError) {
              console.error('CSV parsing failed:', csvError);
              showStatus('error', 'Failed to parse CSV. Please ensure your file is properly formatted.');
              return;
            }
            
          } else {
            workbook = XLSX.read(e.target.result, { type: 'binary' });
            const firstSheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[firstSheetName];
            
            const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
            
            if (jsonData.length === 0) {
              showStatus('error', 'The uploaded file appears to be empty.');
              return;
            }
            
            const headers = jsonData[0];
            const data = jsonData.slice(1).filter(row => row.some(cell => cell !== undefined && cell !== '')).map(row => {
              const rowObj = {};
              headers.forEach((header, index) => {
                rowObj[header] = row[index] || '';
              });
              return rowObj;
            });
            
            parsedPinclicksData = {
              headers: headers,
              data: data
            };
          }
          
          // Validate required columns
          const requiredColumns = ['keyword'];
          const optionalColumns = ['interests', 'keywords', 'category', 'imageurl', 'board', 'pinterest_board', 'pinterestboard'];
          const allColumns = [...requiredColumns, ...optionalColumns];
          
          const headerLower = parsedPinclicksData.headers.map(h => h.toLowerCase());
          const missingRequired = requiredColumns.filter(col => 
            !headerLower.some(h => h.includes(col.toLowerCase()))
          );
          
          if (missingRequired.length > 0) {
            showStatus('error', `Missing required column: "Keyword". Please ensure your file has a column containing the main keywords.`);
            return;
          }
          
          // Create column mapping
          const columnMap = {};
          allColumns.forEach(col => {
            const matchedHeader = parsedPinclicksData.headers.find(h => 
              h.toLowerCase().includes(col.toLowerCase())
            );
            if (matchedHeader) {
              columnMap[col] = matchedHeader;
            }
          });
          
          // Try to find interests/keywords column
          if (!columnMap.interests && !columnMap.keywords) {
            // Look for any column that might contain interests
            const possibleInterestColumns = parsedPinclicksData.headers.filter(h =>
              h.toLowerCase().includes('interest') ||
              h.toLowerCase().includes('tag') ||
              h.toLowerCase().includes('topic') ||
              h.toLowerCase().includes('related')
            );

            if (possibleInterestColumns.length > 0) {
              columnMap.interests = possibleInterestColumns[0];
            }
          }

          // Try to find Pinterest board column
          if (!columnMap.board && !columnMap.pinterest_board && !columnMap.pinterestboard) {
            // Look for any column that might contain board name
            const possibleBoardColumns = parsedPinclicksData.headers.filter(h =>
              h.toLowerCase().includes('board') ||
              h.toLowerCase().includes('pinterest board') ||
              h.toLowerCase().includes('pin board')
            );

            if (possibleBoardColumns.length > 0) {
              columnMap.board = possibleBoardColumns[0];
            }
          }
          
          const normalizedData = parsedPinclicksData.data.map(row => {
            const normalized = {};
            Object.keys(columnMap).forEach(key => {
              const headerName = columnMap[key];
              normalized[key] = row[headerName] || '';
            });
            return normalized;
          }).filter(row => row.keyword && row.keyword.trim());
          
          if (normalizedData.length === 0) {
            showStatus('error', 'No valid data found in the file. Please check that you have keywords in the correct column.');
            return;
          }
          
          parsedPinclicksData.normalizedData = normalizedData;
          parsedPinclicksData.columnMap = columnMap;
          
          displayPinclicksExcelPreview(parsedPinclicksData);
          
        } catch (error) {
          console.error('Error parsing file:', error);
          showStatus('error', 'Error reading file: ' + error.message);
        }
      };
      
      if (file.name.toLowerCase().endsWith('.csv')) {
        reader.readAsText(file);
      } else {
        reader.readAsBinaryString(file);
      }
    });
  }

  // Helper function to parse CSV line (same as used in Excel tab)
  function parseCSVLine(line) {
    const values = [];
    let currentValue = '';
    let insideQuotes = false;
    let quoteChar = null;
    
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      
      if ((char === '"' || char === "'") && !insideQuotes) {
        insideQuotes = true;
        quoteChar = char;
      } else if (char === quoteChar && insideQuotes) {
        if (i + 1 < line.length && line[i + 1] === quoteChar) {
          currentValue += char;
          i++;
        } else {
          insideQuotes = false;
          quoteChar = null;
        }
      } else if (char === ',' && !insideQuotes) {
        values.push(currentValue.trim());
        currentValue = '';
      } else {
        currentValue += char;
      }
    }
    
    values.push(currentValue.trim());
    return values;
  }

  // Function to display Excel preview for PinClicks
  function displayPinclicksExcelPreview(data) {
    const previewDiv = document.getElementById('pinclicksExcelPreview');
    const headerElement = document.getElementById('pinclicksExcelPreviewHeader');
    const bodyElement = document.getElementById('pinclicksExcelPreviewBody');
    
    if (!previewDiv || !headerElement || !bodyElement) return;
    
    headerElement.innerHTML = '';
    bodyElement.innerHTML = '';
    
    previewDiv.classList.remove('d-none');

    const headerRow = document.createElement('tr');
    const displayHeaders = ['Keyword', 'Interests/Keywords', 'Category', 'Pinterest Board', 'Image URL'];
    displayHeaders.forEach(header => {
      const th = document.createElement('th');
      th.textContent = header;
      headerRow.appendChild(th);
    });
    headerElement.appendChild(headerRow);

    const previewData = data.normalizedData.slice(0, 5);
    previewData.forEach(row => {
      const tr = document.createElement('tr');

      // Keyword
      const keywordTd = document.createElement('td');
      const keyword = row.keyword || '';
      keywordTd.textContent = keyword.length > 30 ? keyword.substring(0, 27) + '...' : keyword;
      keywordTd.title = keyword;
      tr.appendChild(keywordTd);

      // Interests/Keywords
      const interestsTd = document.createElement('td');
      const interests = row.interests || row.keywords || '';
      interestsTd.textContent = interests.length > 40 ? interests.substring(0, 37) + '...' : interests;
      if (interests.length > 40) {
        interestsTd.title = interests;
      }
      tr.appendChild(interestsTd);

      // Category
      const categoryTd = document.createElement('td');
      categoryTd.textContent = row.category || '';
      tr.appendChild(categoryTd);

      // Pinterest Board
      const boardTd = document.createElement('td');
      const board = row.board || row.pinterest_board || row.pinterestboard || '';
      boardTd.textContent = board;
      boardTd.style.fontWeight = board ? 'bold' : 'normal';
      boardTd.style.color = board ? '#E60023' : '#999';
      if (!board) {
        boardTd.textContent = '(default)';
      }
      tr.appendChild(boardTd);

      // Image URL
      const imageUrlTd = document.createElement('td');
      const imageUrl = row.imageurl || '';
      imageUrlTd.textContent = imageUrl.length > 30 ? imageUrl.substring(0, 27) + '...' : imageUrl;
      if (imageUrl.length > 30) {
        imageUrlTd.title = imageUrl;
      }
      tr.appendChild(imageUrlTd);

      bodyElement.appendChild(tr);
    });
    
    showStatus('success', 
      `File parsed successfully! Found ${data.normalizedData.length} keywords with interests. Preview shows first 5 rows.`
    );
  }

  // Enhanced PinClicks Analysis Button with Recipe Support
  const analyzePinclicksBtn = document.getElementById('analyzePinclicksBtn');
  if (analyzePinclicksBtn) {
    analyzePinclicksBtn.addEventListener('click', function() {
      const pinclicksFile = document.getElementById('pinclicksFile');
      const pinclicksExcelFile = document.getElementById('pinclicksExcelFile');
      const pinclicksRecipeInput = document.getElementById('pinclicksRecipeInput'); // Changed from pinclicksKeyword
      const pinclicksCategory = document.getElementById('pinclicksCategory');
      const pinclicksImageUrl = document.getElementById('pinclicksImageUrl');
      
      // Check which tab is active
      const csvTabActive = document.getElementById('pinclicks-csv').classList.contains('active');
      const excelTabActive = document.getElementById('pinclicks-excel').classList.contains('active');
      
      if (csvTabActive) {
        // Handle CSV upload with enhanced recipe support
        const file = pinclicksFile.files[0];
        const recipeInput = pinclicksRecipeInput.value.trim(); // Get recipe input instead of just keyword
        
        if (!file) {
          showStatus('error', 'Please upload a PinClicks CSV file.');
          return;
        }
        
        if (!recipeInput) {
          showStatus('error', 'Please enter a keyword or complete recipe for this analysis.');
          return;
        }
        
        // Detect if this is a full recipe or just a keyword (using the same logic as manual entry)
        const isFullRecipe = detectFullRecipe(recipeInput);
        
        let keyword;
        let fullRecipe = null;
        
        if (isFullRecipe) {
          // Extract title from full recipe (using the same logic as manual entry)
          keyword = extractRecipeTitle(recipeInput);
          fullRecipe = recipeInput;
          console.log(`PinClicks: Detected full recipe with title: "${keyword}"`);
        } else {
          // Simple keyword
          keyword = recipeInput;
          console.log(`PinClicks: Detected simple keyword: "${keyword}"`);
        }
        
        analyzePinclicksBtn.disabled = true;
        analyzePinclicksBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Analyzing...';
        
        const reader = new FileReader();
        reader.onload = function(e) {
          const csvData = e.target.result;
          
          fetch('/api/analyze-pinclicks', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              csv: csvData,
              keyword: keyword,
              full_recipe: fullRecipe, // Pass the full recipe if detected
              category: pinclicksCategory.value,
              image_url: pinclicksImageUrl.value
            })
          })
          .then(response => {
            if (!response.ok) {
              throw new Error(`Server responded with status: ${response.status}`);
            }
            return response.json();
          })
          .then(data => {
            if (data.success) {
              analyzedPinclicksResults = [{
                keyword: keyword,
                full_recipe: fullRecipe, // Store the full recipe
                category: pinclicksCategory.value,
                interests: data.interests,
                image_url: pinclicksImageUrl.value
              }];
              
              displayPinclicksResults(analyzedPinclicksResults);
              
              document.getElementById('pinclicksAnalysisResult').classList.remove('d-none');
              document.getElementById('addFromPinclicksBtn').classList.remove('d-none');
              
              showStatus('success', 'Analysis complete! Review the extracted interests below.');
            } else {
              throw new Error(data.message || 'Failed to analyze PinClicks data');
            }
          })
          .catch(error => {
            console.error('Error analyzing PinClicks data:', error);
            showStatus('error', error.message || 'An unknown error occurred');
          })
          .finally(() => {
            analyzePinclicksBtn.disabled = false;
            analyzePinclicksBtn.innerHTML = 'Analyze File';
          });
        };
        
        reader.onerror = function(error) {
          console.error('Error reading file:', error);
          showStatus('error', 'Failed to read file');
          analyzePinclicksBtn.disabled = false;
          analyzePinclicksBtn.innerHTML = 'Analyze File';
        };
        
        reader.readAsText(file);
        
      } else if (excelTabActive) {
        // Handle Excel upload (existing logic unchanged)
        if (!parsedPinclicksData || !parsedPinclicksData.normalizedData) {
          showStatus('error', 'Please upload and preview an Excel file first.');
          return;
        }
        
        analyzePinclicksBtn.disabled = true;
        analyzePinclicksBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Analyzing...';
        
        // Process the parsed Excel data
        const defaultCategory = pinclicksCategory.value;
        const defaultImageUrl = pinclicksImageUrl.value;
        
        analyzedPinclicksResults = parsedPinclicksData.normalizedData.map(row => {
          return {
            keyword: row.keyword.trim(),
            category: row.category && row.category.trim() ? row.category.trim() : defaultCategory,
            interests: row.interests || row.keywords || '',
            image_url: row.imageurl && row.imageurl.trim() ? row.imageurl.trim() : defaultImageUrl,
            pinterest_board: row.board || row.pinterest_board || row.pinterestboard || null
          };
        });
        
        displayPinclicksResults(analyzedPinclicksResults);
        
        document.getElementById('pinclicksAnalysisResult').classList.remove('d-none');
        document.getElementById('addFromPinclicksBtn').classList.remove('d-none');
        
        showStatus('success', `Analysis complete! Processed ${analyzedPinclicksResults.length} keywords with interests.`);
        
        analyzePinclicksBtn.disabled = false;
        analyzePinclicksBtn.innerHTML = 'Analyze File';
      }
    });
  }

  // Function to display PinClicks results with recipe detection
  function displayPinclicksResults(results) {
    const container = document.getElementById('pinclicksResultsContainer');
    if (!container) return;
    
    container.innerHTML = '';
    
    if (results.length === 1) {
      // Single result (CSV mode)
      const result = results[0];
      container.innerHTML = `
        <p><strong>Extracted Interests:</strong></p>
        <div class="p-3 bg-light rounded">${result.interests}</div>
      `;
      
      // Show whether it's a full recipe or keyword
      if (result.full_recipe) {
        container.innerHTML += `<div class="alert alert-info mt-2">
          <strong>üìù Full Recipe Detected:</strong> "${result.keyword}"<br>
          <small>Complete recipe will be stored with these extracted interests.</small>
        </div>`;
      } else {
        container.innerHTML += `<div class="alert alert-warning mt-2">
          <strong>ü§ñ Keyword Detected:</strong> "${result.keyword}"<br>
          <small>AI will generate a full recipe with these extracted interests.</small>
        </div>`;
      }
    } else {
      // Multiple results (Excel mode)
      container.innerHTML = `
        <p><strong>Processed ${results.length} Keywords:</strong></p>
        <div class="table-responsive">
          <table class="table table-sm">
            <thead>
              <tr>
                <th>Keyword</th>
                <th>Interests</th>
                <th>Category</th>
              </tr>
            </thead>
            <tbody>
              ${results.map(result => `
                <tr>
                  <td><strong>${result.keyword}</strong></td>
                  <td>${result.interests.length > 50 ? result.interests.substring(0, 47) + '...' : result.interests}</td>
                  <td>${result.category || 'Default'}</td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>
      `;
    }
  }

  // Enhanced Add from PinClicks button with recipe support
  const addFromPinclicksBtn = document.getElementById('addFromPinclicksBtn');
  if (addFromPinclicksBtn) {
    addFromPinclicksBtn.addEventListener('click', function() {
      if (!analyzedPinclicksResults || analyzedPinclicksResults.length === 0) {
        showStatus('error', 'Please analyze the file first.');
        return;
      }
      
      addFromPinclicksBtn.disabled = true;
      addFromPinclicksBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Adding...';

      const defaultPinterestBoard = document.getElementById('pinclicksPinterestBoard').value || 'Dinner';

      // Prepare the data in the same format as manual entry and Excel upload
      const keywordsData = analyzedPinclicksResults.map(result => ({
        keyword: result.keyword,
        full_recipe: result.full_recipe, // Include full recipe if available
        category: result.category,
        interests: result.interests,
        image_url: result.image_url,
        // Use board from CSV if available, otherwise use default from dropdown
        pinterest_board: result.pinterest_board || defaultPinterestBoard
      }));
      
      console.log('Adding PinClicks keywords:', keywordsData.map(item => ({
        keyword: item.keyword,
        has_full_recipe: !!item.full_recipe,
        category: item.category
      })));
      
      fetch('/api/keywords/add', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          keywords: keywordsData // Send as array to match the expected format
        })
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          const count = analyzedPinclicksResults.length;
          if (count === 1) {
            const recipeType = analyzedPinclicksResults[0].full_recipe ? 'recipe' : 'keyword';
            showStatus('success', `Successfully added ${recipeType} "${analyzedPinclicksResults[0].keyword}" with extracted interests!`);
          } else {
            showStatus('success', `Successfully added ${count} keyword${count > 1 ? 's' : ''} with extracted interests!`);
          }
          
          // Reset form
          document.getElementById('pinclicksFile').value = '';
          document.getElementById('pinclicksExcelFile').value = '';
          document.getElementById('pinclicksRecipeInput').value = ''; // Changed from pinclicksKeyword
          document.getElementById('pinclicksCategory').value = '';
          document.getElementById('pinclicksImageUrl').value = '';
          document.getElementById('pinclicksAnalysisResult').classList.add('d-none');
          document.getElementById('pinclicksExcelPreview').classList.add('d-none');
          addFromPinclicksBtn.classList.add('d-none');
          analyzedPinclicksResults = null;
          parsedPinclicksData = null;
          
          setTimeout(() => {
            window.location.reload();
          }, 1500);
        } else {
          throw new Error(data.message || 'Failed to add keywords');
        }
      })
      .catch(error => {
        console.error('Error adding keywords from PinClicks:', error);
        showStatus('error', error.message || 'An unknown error occurred');
      })
      .finally(() => {
        addFromPinclicksBtn.disabled = false;
        addFromPinclicksBtn.innerHTML = 'Add Keywords with Interests';
      });
    });
  }

  // Prompt editing functionality
  const promptEditModal = document.getElementById('promptEditModal');
  if (promptEditModal) {
    let promptEditModalInstance = new bootstrap.Modal(promptEditModal);
    
    const promptEditSaveBtn = document.getElementById('promptEditSaveBtn');
    if (promptEditSaveBtn) {
      promptEditSaveBtn.addEventListener('click', async function() {
        const recipeId = document.getElementById('promptEditRecipeId').value;
        const prompt = document.getElementById('promptEditText').value;
        
        if (!recipeId || !prompt.trim()) {
          document.getElementById('promptEditAlert').classList.remove('d-none');
          document.getElementById('promptEditBlockedTerms').textContent = 'Please provide a valid prompt.';
          return;
        }
        
        promptEditSaveBtn.disabled = true;
        promptEditSaveBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Generating...';
        document.getElementById('promptEditForm').classList.add('d-none');
        document.getElementById('promptEditSpinner').classList.remove('d-none');
        
        try {
          const response = await fetch('/midjourney/api/generate-with-prompt', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              recipeId,
              prompt
            })
          });
          
          const data = await response.json();
          
          if (data.success) {
            promptEditModalInstance.hide();
            
            showStatus('success', 'Image generation started with edited prompt');
            
            const statusCell = document.querySelector(`.image-status-cell[data-recipe-id="${recipeId}"]`);
            if (statusCell) {
              statusCell.innerHTML = `<span class="badge bg-warning">‚è≥ Pending</span>`;
            }
            
            document.getElementById('promptEditForm').reset();
          } else if (data.safetyCheck && data.safetyCheck.blocked) {
            document.getElementById('promptEditAlert').classList.remove('d-none');
            document.getElementById('promptEditBlockedTerms').textContent = 
              data.safetyCheck.terms.join(', ');
            
            document.getElementById('promptEditForm').classList.remove('d-none');
            document.getElementById('promptEditSpinner').classList.add('d-none');
          } else {
            throw new Error(data.error || 'Failed to generate image');
          }
        } catch (error) {
          console.error('Error generating image with edited prompt:', error);
          document.getElementById('promptEditAlert').classList.remove('d-none');
          document.getElementById('promptEditBlockedTerms').textContent = 
            error.message || 'An unknown error occurred';
        } finally {
          promptEditSaveBtn.disabled = false;
          promptEditSaveBtn.innerHTML = 'Generate Image';
          document.getElementById('promptEditForm').classList.remove('d-none');
          document.getElementById('promptEditSpinner').classList.add('d-none');
        }
      });
    }
    
    promptEditModal.addEventListener('hidden.bs.modal', function() {
      document.getElementById('promptEditForm').reset();
      document.getElementById('promptEditAlert').classList.add('d-none');
      document.getElementById('promptEditForm').classList.remove('d-none');
      document.getElementById('promptEditSpinner').classList.add('d-none');
      promptEditSaveBtn.disabled = false;
      promptEditSaveBtn.innerHTML = 'Generate Image';
    });
  }

  // Excel file input handler
  const excelFileInput = document.getElementById('excelFile');
  if (excelFileInput) {
    excelFileInput.addEventListener('change', function(event) {
      const file = event.target.files[0];
      if (!file) {
        document.getElementById('excelPreview').classList.add('d-none');
        parsedExcelData = null;
        return;
      }
      
      const allowedTypes = [
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'application/vnd.ms-excel',
        'text/csv'
      ];
      
      if (!allowedTypes.includes(file.type) && !file.name.match(/\.(xlsx|xls|csv)$/i)) {
        showStatus('error', 'Please upload a valid Excel file (.xlsx, .xls) or CSV file.');
        return;
      }
      
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          let workbook;
          
          if (file.name.toLowerCase().endsWith('.csv')) {
            const csvData = e.target.result;
            
            console.log('üìÑ Raw CSV data preview:', csvData.substring(0, 200) + '...');
            
            // ROBUST CSV PARSING: Handle commas within recipe content properly
            try {
              const lines = [];
              let currentLine = '';
              let insideQuotes = false;
              let quoteChar = null;
              
              for (let i = 0; i < csvData.length; i++) {
                const char = csvData[i];
                
                // Handle quote detection
                if ((char === '"' || char === "'") && !insideQuotes) {
                  insideQuotes = true;
                  quoteChar = char;
                  currentLine += char;
                } else if (char === quoteChar && insideQuotes) {
                  // Check for escaped quotes (double quotes)
                  if (i + 1 < csvData.length && csvData[i + 1] === quoteChar) {
                    currentLine += char + char;
                    i++; // Skip the next quote
                  } else {
                    insideQuotes = false;
                    quoteChar = null;
                    currentLine += char;
                  }
                } else if (char === '\n' && !insideQuotes) {
                  if (currentLine.trim()) {
                    lines.push(currentLine.trim());
                  }
                  currentLine = '';
                } else {
                  currentLine += char;
                }
              }
              
              // Add the last line if it exists
              if (currentLine.trim()) {
                lines.push(currentLine.trim());
              }
              
              console.log('üìÑ CSV Lines parsed:', lines.length);
              lines.forEach((line, index) => {
                console.log(`Line ${index + 1}:`, line.substring(0, 150) + (line.length > 150 ? '...' : ''));
              });
              
              if (lines.length === 0) {
                throw new Error('No data found in CSV');
              }
              
              // Parse header line with proper CSV logic
              const headerLine = lines[0];
              const headers = parseCSVLine(headerLine);
              
              console.log('üìã Headers found:', headers);
              
              // Process data rows with proper CSV parsing
              const rows = [];
              for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                if (line.trim()) {
                  const values = parseCSVLine(line);
                  
                  console.log(`üìù Raw values for row ${i}:`, values.map(v => v.substring(0, 100) + (v.length > 100 ? '...' : '')));
                  
                  const row = {};
                  headers.forEach((header, index) => {
                    row[header] = values[index] || '';
                  });
                  
                  console.log(`üìù Processed row ${i}:`, {
                    keyword: (row.keyword || '').substring(0, 150) + (row.keyword && row.keyword.length > 150 ? '...' : ''),
                    keywordLength: (row.keyword || '').length,
                    imageUrl: (row.imageurl || row.ImageUrl || '').substring(0, 50),
                    otherColumns: Object.keys(row).filter(k => k !== 'keyword' && !k.toLowerCase().includes('imageurl'))
                  });
                  
                  rows.push(row);
                }
              }
              
              parsedExcelData = {
                headers: headers,
                data: rows
              };
              
            } catch (csvError) {
              console.error('‚ùå Enhanced CSV parsing failed:', csvError);
              showStatus('error', 'Failed to parse CSV. Please ensure your recipe content is properly quoted in the CSV file.');
              return;
            }
          } else {
            workbook = XLSX.read(e.target.result, { type: 'binary' });
            const firstSheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[firstSheetName];
            
            const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
            
            if (jsonData.length === 0) {
              showStatus('error', 'The uploaded file appears to be empty.');
              return;
            }
            
            const headers = jsonData[0];
            const data = jsonData.slice(1).filter(row => row.some(cell => cell !== undefined && cell !== '')).map(row => {
              const rowObj = {};
              headers.forEach((header, index) => {
                rowObj[header] = row[index] || '';
              });
              return rowObj;
            });
            
            parsedExcelData = {
              headers: headers,
              data: data
            };
          }
          
          const requiredColumns = ['keyword'];
          const optionalColumns = ['category', 'interests', 'imageurl', 'fullrecipe']; // Added fullrecipe
          const allColumns = [...requiredColumns, ...optionalColumns];
          
          const headerLower = parsedExcelData.headers.map(h => h.toLowerCase());
          const missingRequired = requiredColumns.filter(col => 
            !headerLower.some(h => h.includes(col.toLowerCase()))
          );
          
          if (missingRequired.length > 0) {
            showStatus('error', `Missing required column(s): ${missingRequired.join(', ')}. Please ensure your file has a "Keyword" column.`);
            return;
          }
          
          const columnMap = {};
          allColumns.forEach(col => {
            const matchedHeader = parsedExcelData.headers.find(h => 
              h.toLowerCase().includes(col.toLowerCase())
            );
            if (matchedHeader) {
              columnMap[col] = matchedHeader;
            }
          });
          
          const normalizedData = parsedExcelData.data.map(row => {
            const normalized = {};
            Object.keys(columnMap).forEach(key => {
              const headerName = columnMap[key];
              normalized[key] = row[headerName] || '';
            });
            return normalized;
          }).filter(row => row.keyword && row.keyword.trim());
          
          if (normalizedData.length === 0) {
            showStatus('error', 'No valid data found in the file. Please check that you have keywords in the correct column.');
            return;
          }
          
          parsedExcelData.normalizedData = normalizedData;
          parsedExcelData.columnMap = columnMap;
          
          displayExcelPreview(parsedExcelData);
          
        } catch (error) {
          console.error('Error parsing file:', error);
          showStatus('error', 'Error reading file: ' + error.message);
        }
      };
      
      if (file.name.toLowerCase().endsWith('.csv')) {
        reader.readAsText(file);
      } else {
        reader.readAsBinaryString(file);
      }
    });
  }

  // Function to display Excel preview
  function displayExcelPreview(data) {
    const previewDiv = document.getElementById('excelPreview');
    const headerElement = document.getElementById('excelPreviewHeader');
    const bodyElement = document.getElementById('excelPreviewBody');
    
    if (!previewDiv || !headerElement || !bodyElement) return;
    
    headerElement.innerHTML = '';
    bodyElement.innerHTML = '';
    
    previewDiv.classList.remove('d-none');
    
    const headerRow = document.createElement('tr');
    // SIMPLIFIED: Show recipe type instead of separate columns
    const displayHeaders = ['Recipe Content', 'Type', 'Category', 'Interests', 'Image URL'];
    displayHeaders.forEach(header => {
      const th = document.createElement('th');
      th.textContent = header;
      headerRow.appendChild(th);
    });
    headerElement.appendChild(headerRow);
    
    const previewData = data.normalizedData.slice(0, 5);
    previewData.forEach(row => {
      const tr = document.createElement('tr');
      
      // Recipe Content (truncated for display)
      const contentTd = document.createElement('td');
      const keyword = row.keyword || '';
      contentTd.textContent = keyword.length > 50 ? keyword.substring(0, 47) + '...' : keyword;
      contentTd.title = keyword; // Full text on hover
      contentTd.style.maxWidth = '200px';
      tr.appendChild(contentTd);
      
      // Recipe Type (automatically detected)
      const typeTd = document.createElement('td');
      if (row.isFullRecipe) {
        typeTd.innerHTML = '<span class="badge bg-success">üìù FULL RECIPE</span>';
      } else {
        typeTd.innerHTML = '<span class="badge bg-warning">ü§ñ AI RECIPE</span>';
      }
      tr.appendChild(typeTd);
      
      // Category
      const categoryTd = document.createElement('td');
      categoryTd.textContent = row.category || '';
      tr.appendChild(categoryTd);
      
      // Interests
      const interestsTd = document.createElement('td');
      const interests = row.interests || '';
      interestsTd.textContent = interests.length > 30 ? interests.substring(0, 27) + '...' : interests;
      if (interests.length > 30) {
        interestsTd.title = interests;
      }
      tr.appendChild(interestsTd);
      
      // Image URL
      const imageUrlTd = document.createElement('td');
      const imageUrl = row.imageurl || '';
      imageUrlTd.textContent = imageUrl.length > 30 ? imageUrl.substring(0, 27) + '...' : imageUrl;
      if (imageUrl.length > 30) {
        imageUrlTd.title = imageUrl;
      }
      tr.appendChild(imageUrlTd);
      
      bodyElement.appendChild(tr);
    });
    
    // Show statistics about detected recipe types
    const fullRecipeCount = data.normalizedData.filter(row => row.isFullRecipe).length;
    const aiRecipeCount = data.normalizedData.length - fullRecipeCount;
    
    showStatus('success', 
      `File parsed successfully! Found ${data.normalizedData.length} total items: ` +
      `${fullRecipeCount} full recipes, ${aiRecipeCount} keywords for AI generation. Preview shows first 5 rows.`
    );
  }

  function detectFullRecipe(text) {
    if (!text || typeof text !== 'string') {
      console.log('‚ùå Not a string or empty text');
      return false;
    }
    
    console.log('üîç Analyzing text for recipe detection:', text.substring(0, 100) + '...');
    
    const textLower = text.toLowerCase();
    
    // ENHANCED: Check if it contains ingredient markers (works for single-line too)
    const hasIngredients = textLower.includes('ingredients:') || 
                          textLower.includes('ingredient:') ||
                          /ingredients?\s*[:]/i.test(textLower) ||
                          textLower.includes('what you need:') ||
                          textLower.includes('you will need:');
    
    // ENHANCED: Check if it contains instruction markers (works for single-line too)
    const hasInstructions = textLower.includes('instructions:') || 
                           textLower.includes('instruction:') ||
                           textLower.includes('preparation:') ||
                           textLower.includes('method:') ||
                           textLower.includes('directions:') ||
                           textLower.includes('steps:') ||
                           textLower.includes('how to make:') ||
                           /instructions?\s*[:]/i.test(textLower) ||
                           /preparation\s*[:]/i.test(textLower) ||
                           /directions?\s*[:]/i.test(textLower) ||
                           /method\s*[:]/i.test(textLower);
    
    // Check if it has multiple lines (but don't require it)
    const lines = text.split('\n').filter(line => line.trim());
    const hasMultipleLines = lines.length > 3;
    
    // ENHANCED: Check if it contains measurements (more comprehensive)
    const hasMeasurements = /\b\d+\s*(cup|cups|c\.|tbsp|tsp|tablespoon|tablespoons|teaspoon|teaspoons|lb|lbs|oz|ounce|ounces|pound|pounds|gram|grams|g\.|ml|milliliter|liter|l\.|quart|pint|gallon|kg|kilogram)\b/i.test(text);
    
    // Check for numbered steps (works in single line if steps are numbered)
    const hasNumberedSteps = /\b\d+[\.\)]\s*[A-Z][a-z]/g.test(text) || /step\s*\d+/i.test(text);
    
    // Check for bulleted ingredients (- or ‚Ä¢ or *) - less useful for single line
    const hasBulletedItems = /^\s*[-‚Ä¢*]\s+/m.test(text);
    
    // ENHANCED: Check for cooking verbs (expanded list)
    const hasCookingVerbs = /\b(preheat|bake|cook|stir|mix|blend|whisk|beat|fold|saut√©|sautee|fry|boil|simmer|roast|grill|chop|dice|slice|season|add|combine|heat|cool|chill|serve|pour|remove|grease|flour|dissolve|thicken|melt|frost)\b/i.test(text);
    
    // ENHANCED: Check for temperature mentions
    const hasTemperatures = /\b\d+\s*¬∞?[CF]\b|\b\d+\s*degrees?\b|\b(fahrenheit|celsius)\b/i.test(text);
    
    // ENHANCED: Check for time mentions
    const hasTimeReferences = /\b\d+\s*(minute|minutes|min|hour|hours|hr|hrs|second|seconds|sec)\b/i.test(text);
    
    // NEW: Check for recipe-specific content length (single-line recipes are usually long)
    const hasSubstantialContent = text.length > 200;
    
    // NEW: Check for multiple cooking actions in sequence
    const cookingActionCount = (text.match(/\b(preheat|bake|cook|stir|mix|blend|whisk|beat|fold|saut√©|sautee|fry|boil|simmer|roast|grill|chop|dice|slice|season|add|combine|heat|cool|chill|serve|pour|remove|grease|flour|dissolve|thicken|melt|frost)\b/gi) || []).length;
    const hasMultipleCookingActions = cookingActionCount >= 3;
    
    // NEW: Check for ingredient-like patterns (numbers with measurements near food words)
    const ingredientPatterns = /\b\d+\s*(?:cup|cups|tbsp|tsp|tablespoon|teaspoon|lb|oz|gram|ml|liter|kg)s?\s+(?:of\s+)?[a-z]/gi;
    const hasIngredientPatterns = (text.match(ingredientPatterns) || []).length >= 3;
    
    // Log all detection results
    console.log('üîç Detection Results:', {
      hasIngredients,
      hasInstructions,
      hasMultipleLines,
      hasMeasurements,
      hasNumberedSteps,
      hasBulletedItems,
      hasCookingVerbs,
      hasTemperatures,
      hasTimeReferences,
      hasSubstantialContent,
      hasMultipleCookingActions,
      hasIngredientPatterns,
      cookingActionCount,
      textLength: text.length,
      lineCount: lines.length
    });
    
    // PRIORITY 1: Definitive full recipe detection
    if (hasIngredients && hasInstructions) {
      console.log('‚úÖ Full recipe detected: Has both ingredients and instructions sections');
      return true;
    }
    
    // PRIORITY 2: Single-line recipe with strong indicators
    if (hasSubstantialContent && hasIngredients && hasMeasurements && hasMultipleCookingActions) {
      console.log('‚úÖ Full recipe detected: Single-line recipe with ingredients, measurements, and multiple cooking actions');
      return true;
    }
    
    // PRIORITY 3: Single-line recipe with instructions and strong content
    if (hasSubstantialContent && hasInstructions && hasMeasurements && hasMultipleCookingActions) {
      console.log('‚úÖ Full recipe detected: Single-line recipe with instructions, measurements, and cooking actions');
      return true;
    }
    
    // PRIORITY 4: Recipe with ingredient patterns and cooking actions
    if (hasIngredientPatterns && hasMultipleCookingActions && hasSubstantialContent) {
      console.log('‚úÖ Full recipe detected: Has ingredient patterns and multiple cooking actions');
      return true;
    }
    
    // PRIORITY 5: Multi-line recipe with multiple indicators
    const indicators = [
      hasMultipleLines,
      hasMeasurements,
      hasNumberedSteps,
      hasBulletedItems,
      hasCookingVerbs,
      hasTemperatures,
      hasTimeReferences
    ];
    
    const indicatorCount = indicators.filter(Boolean).length;
    
    if (indicatorCount >= 4 && hasMultipleLines) {
      console.log(`‚úÖ Full recipe detected: ${indicatorCount}/7 indicators present with multiple lines`);
      return true;
    }
    
    // PRIORITY 6: Any recipe with measurements, cooking verbs, and substantial content
    if (hasMeasurements && hasCookingVerbs && hasSubstantialContent && (hasTemperatures || hasTimeReferences)) {
      console.log('‚úÖ Full recipe detected: Has measurements, cooking verbs, substantial content, and temperature/time references');
      return true;
    }
    
    // Log detection results for debugging
    console.log(`ü§ñ AI recipe detected: ${indicatorCount}/7 traditional indicators, ${cookingActionCount} cooking actions for "${text.substring(0, 50)}..."`);
    
    return false;
  }

  // ENHANCED: Helper function to extract recipe title
  function extractRecipeTitle(recipeText) {
    if (!recipeText || typeof recipeText !== 'string') {
      return 'Recipe';
    }
    
    console.log('üè∑Ô∏è Extracting title from recipe:', recipeText.substring(0, 100) + '...');
    
    // Method 1: Try to find content before "Ingredients:" (works for single-line)
    const ingredientsMatch = recipeText.match(/^(.*?)\s*Ingredients?\s*[:]/i);
    if (ingredientsMatch && ingredientsMatch[1].trim()) {
      const title = ingredientsMatch[1].trim();
      console.log('‚úÖ Title extracted using Ingredients marker:', title);
      return title;
    }
    
    // Method 2: Try to find content before "Instructions:" 
    const instructionsMatch = recipeText.match(/^(.*?)\s*Instructions?\s*[:]/i);
    if (instructionsMatch && instructionsMatch[1].trim()) {
      const title = instructionsMatch[1].trim();
      console.log('‚úÖ Title extracted using Instructions marker:', title);
      return title;
    }
    
    // Method 3: For multi-line recipes, use first line
    const lines = recipeText.split('\n').filter(line => line.trim());
    if (lines.length > 1) {
      const firstLine = lines[0].trim();
      // Make sure it's not just "Ingredients:" or "Instructions:"
      if (firstLine && !firstLine.toLowerCase().match(/^(ingredients?|instructions?)\s*[:]*$/)) {
        console.log('‚úÖ Title extracted from first line:', firstLine);
        return firstLine;
      }
    }
    
    // Method 4: Try to extract first sentence (for single-line recipes)
    const sentences = recipeText.split(/[.!?]/).filter(s => s.trim());
    if (sentences.length > 0) {
      const firstSentence = sentences[0].trim();
      // Make sure it's reasonable length for a title (not too long)
      if (firstSentence.length > 5 && firstSentence.length < 100) {
        console.log('‚úÖ Title extracted from first sentence:', firstSentence);
        return firstSentence;
      }
    }
    
    // Method 5: Fallback - take first reasonable chunk of words
    const words = recipeText.trim().split(/\s+/);
    if (words.length >= 3) {
      // Take first 3-8 words as title
      const titleWords = words.slice(0, Math.min(8, words.length));
      const title = titleWords.join(' ');
      
      // Stop at "Ingredients" if it appears
      const beforeIngredients = title.split(/\s*Ingredients?\s*/i)[0];
      if (beforeIngredients.trim()) {
        console.log('‚úÖ Title extracted from first words:', beforeIngredients.trim());
        return beforeIngredients.trim();
      }
    }
    
    // Ultimate fallback
    console.log('‚ö†Ô∏è Using fallback title');
    return 'Recipe';
  }

  // Handle Excel tab submission
  function handleExcelTabSubmission() {
    if (!parsedExcelData || !parsedExcelData.normalizedData) {
      showStatus('error', 'Please upload and preview an Excel file first.');
      return null;
    }
    
    const defaultCategory = document.getElementById('defaultCategory').value;
    const defaultInterests = document.getElementById('defaultInterests').value;
    const defaultImageUrl = document.getElementById('excelDefaultImageUrl').value;
    const pinterestBoard = document.getElementById('excelPinterestBoard').value || 'Dinner';

    // Process each row - same logic as manual entry
    const keywordsToAdd = parsedExcelData.normalizedData.map(row => {
      const keywordText = row.keyword.trim();

      // Use the same detection logic as manual entry
      const isFullRecipe = detectFullRecipe(keywordText);

      let keyword;

      if (isFullRecipe) {
        // ENHANCED: Use the same title extraction logic as manual entry
        keyword = extractRecipeTitle(keywordText);
      } else {
        // For simple keywords, use the input as-is
        keyword = keywordText;
      }

      // DEBUG: Log what we're processing
      console.log(`Excel processing: "${keyword}" - Full recipe: ${isFullRecipe}`);
      if (isFullRecipe) {
        console.log(`  Recipe length: ${keywordText.length} characters`);
        console.log(`  Extracted title: "${keyword}"`);
        console.log(`  First 100 chars: ${keywordText.substring(0, 100)}...`);
      }

      return {
        keyword: keyword,
        full_recipe: isFullRecipe ? keywordText : null, // Store full recipe if detected
        category: row.category && row.category.trim() ? row.category.trim() : defaultCategory,
        interests: row.interests && row.interests.trim() ? row.interests.trim() : defaultInterests,
        image_url: row.imageurl && row.imageurl.trim() ? row.imageurl.trim() : defaultImageUrl,
        pinterest_board: pinterestBoard
      };
    });
    
    // DEBUG: Log the final processed data
    console.log('=== EXCEL SUBMISSION DEBUG ===');
    console.log(`Total items: ${keywordsToAdd.length}`);
    const fullRecipeCount = keywordsToAdd.filter(item => item.full_recipe).length;
    console.log(`Full recipes: ${fullRecipeCount}`);
    console.log(`AI recipes: ${keywordsToAdd.length - fullRecipeCount}`);
    
    keywordsToAdd.slice(0, 3).forEach((item, index) => {
      console.log(`Item ${index + 1}:`, {
        keyword: item.keyword,
        has_full_recipe: !!item.full_recipe,
        full_recipe_preview: item.full_recipe ? item.full_recipe.substring(0, 50) + '...' : 'None'
      });
    });
    console.log('=== END EXCEL SUBMISSION DEBUG ===');
    
    return {
      keywords: keywordsToAdd
    };
  }

  // Add Keywords form submission
  const addKeywordsForm = document.getElementById('addKeywordsForm');
  if (addKeywordsForm) {
    addKeywordsForm.addEventListener('submit', function(event) {
      event.preventDefault();

      const activeTab = getCurrentActiveTab();
      const addBtn = document.getElementById('addBtn');
      if (addBtn) {
        addBtn.disabled = true;
        addBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Adding...';
      }

      let formData;
      
      if (activeTab === 'manual-tab') {
        const keywords = document.getElementById('keywords').value.trim();
        const defaultCategory = document.getElementById('defaultCategory').value;
        const defaultInterests = document.getElementById('defaultInterests').value;
        const imageUrl = document.getElementById('imageUrl').value.trim();
        const pinterestBoard = document.getElementById('pinterestBoard').value || 'Dinner';

        if (!keywords) {
          showStatus('error', 'Please enter at least one recipe.');
          if (addBtn) {
            addBtn.disabled = false;
            addBtn.innerHTML = 'Add Keywords';
          }
          return;
        }

        // Split by "---" instead of lines to handle full recipes
        const recipesList = keywords.split('---')
          .map(recipe => recipe.trim())
          .filter(recipe => recipe.length > 0);

       formData = {
    keywords: recipesList.map(recipeInput => {
      // Extract the first line as the title/keyword
      const lines = recipeInput.split('\n').filter(line => line.trim());
      const keyword = lines.length > 0 ? lines[0].trim() : 'Recipe';

      // DETECT if this is a full recipe or just a keyword
      const isFullRecipe = detectFullRecipe(recipeInput);

      return {
        keyword: keyword,
        full_recipe: isFullRecipe ? recipeInput : null, // Only store if full recipe
        category: defaultCategory,
        interests: defaultInterests,
        image_url: imageUrl,
        pinterest_board: pinterestBoard
      };
    })
  };
        
      } else if (activeTab === 'excel-tab') {
        formData = handleExcelTabSubmission();
        if (!formData) {
          if (addBtn) {
            addBtn.disabled = false;
            addBtn.innerHTML = 'Add Keywords';
          }
          return;
        }
        
      } else if (activeTab === 'pinclicks-tab') {
        if (!analyzedPinclicksResults) {
          showStatus('error', 'Please analyze the CSV file first.');
          if (addBtn) {
            addBtn.disabled = false;
            addBtn.innerHTML = 'Add Keywords';
          }
          return;
        }
        
        formData = {
          keywords: analyzedPinclicksResults
        };
      }
      
      // DEBUG: Log what we're about to send
      console.log('=== DEBUG: About to submit ===');
      console.log('Active tab:', activeTab);
      console.log('Form data:', JSON.stringify(formData, null, 2));
      console.log('Number of items:', formData.keywords.length);
      formData.keywords.forEach((item, index) => {
        console.log(`Item ${index + 1}:`, {
          keyword: item.keyword,
          has_full_recipe: !!item.full_recipe,
          full_recipe_length: item.full_recipe ? item.full_recipe.length : 0
        });
      });
      console.log('=== END DEBUG ===');

      fetch('/api/keywords/add', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(formData)
      })
      .then(response => {
        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
          return response.text().then(text => {
            console.error('Server returned non-JSON response:', text);
            throw new Error(`Server error: ${response.status} ${response.statusText}. Response was HTML instead of JSON. Check server logs.`);
          });
        }
        
        return response.json();
      })
      .then(data => {
        if (data.success) {
          showStatus('success', data.message || `Successfully added ${formData.keywords.length} recipes!`);
          
          addKeywordsForm.reset();
          parsedExcelData = null;
          document.getElementById('excelPreview').classList.add('d-none');
          
          setTimeout(() => {
            window.location.href = '/keywords';
          }, 1500);
        } else {
          throw new Error(data.message || 'Failed to add recipes');
        }
      })
      .catch(error => {
        console.error('Error adding recipes:', error);
        showStatus('error', error.message || 'An unknown error occurred');
      })
      .finally(() => {
        if (addBtn) {
          addBtn.disabled = false;
          addBtn.innerHTML = 'Add Keywords';
        }
      });
    });
  }
   
  // ENHANCED: Auto-start monitoring for keywords with "CHECKING..." status
  function startAutoImageMonitoring() {
    console.log('üîç Checking for keywords with CHECKING status that need monitoring...');
    
    // Find all image badges that show "CHECKING..."
    const checkingBadges = document.querySelectorAll('[data-badge="image"]:not([data-recipe-id=""])');
    
    let startedMonitoring = 0;
    
    checkingBadges.forEach(badge => {
      // Only monitor badges that show "CHECKING..." text
      if (badge.textContent.includes('CHECKING')) {
        const recipeId = badge.getAttribute('data-recipe-id');
        const keywordCard = badge.closest('.keyword-card');
        const keywordId = keywordCard ? keywordCard.getAttribute('data-id') : null;
        
        if (recipeId && keywordId && recipeId !== 'null' && recipeId !== 'undefined') {
          console.log(`üñºÔ∏è Auto-starting monitoring for keyword ${keywordId}, recipe ${recipeId}`);
          startSmartImageMonitoring(recipeId, keywordId);
          startedMonitoring++;
        } else {
          console.log(`‚ö†Ô∏è Skipping badge with invalid IDs: recipe=${recipeId}, keyword=${keywordId}`);
        }
      }
    });
    
    if (startedMonitoring > 0) {
      console.log(`‚úÖ Started automatic monitoring for ${startedMonitoring} keywords with CHECKING status`);
    } else {
      console.log('‚ÑπÔ∏è No keywords found with CHECKING status that need monitoring');
    }
  }

  // Check for ongoing processing on page load and restore progress bar
  async function checkAndRestoreProgressBar() {
    // Look for keywords that are currently processing
    const processingKeywords = document.querySelectorAll('.keyword-card[data-status="processing"]');
    
    if (processingKeywords.length > 0) {
      console.log(`Found ${processingKeywords.length} keywords still processing after page refresh`);
      
      // Get the first processing keyword to determine content type
      const firstKeyword = processingKeywords[0];
      const keywordId = firstKeyword.getAttribute('data-id');
      
      // Get stored content option or default to 'all'
      const contentOption = localStorage.getItem('currentContentOption') || 'all';
      const storedStartTime = localStorage.getItem('processingStartTime');
      
      // Show progress bar
      const progressElement = document.getElementById('processingProgress');
      if (progressElement) {
        progressElement.classList.remove('d-none');
        
        // Initialize progress elements
        document.getElementById('progressCount').textContent = `0 / ${processingKeywords.length}`;
        document.getElementById('progressPercentage').textContent = '0%';
        document.getElementById('successCount').textContent = '0';
        document.getElementById('failedCount').textContent = '0';
        document.getElementById('remainingCount').textContent = processingKeywords.length;
        document.getElementById('elapsedTime').textContent = '00:00';
        document.getElementById('progressText').textContent = 'Restored processing status after page refresh...';
        document.getElementById('currentKeyword').textContent = '';
        
        // Reset workflow steps for the detected content type
        resetWorkflowSteps(contentOption);
        
        // Start monitoring the processing keywords
        const keywordIds = Array.from(processingKeywords).map(card => card.getAttribute('data-id'));
        console.log('Resuming monitoring for keywords:', keywordIds);
        
        // Start batch monitoring (simplified - no database verification needed)
        console.log('üìä Starting resume monitoring for HTML processing keywords');
        startBatchStatusMonitoring(keywordIds);
        
        // Start timer (use stored start time if available)
        const startTime = storedStartTime ? parseInt(storedStartTime) : Date.now();
        window.processingTimeInterval = setInterval(() => {
          const elapsed = Math.floor((Date.now() - startTime) / 1000);
          const minutes = Math.floor(elapsed / 60);
          const seconds = elapsed % 60;
          document.getElementById('elapsedTime').textContent = 
            `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }, 1000);
        
        // Show a status message
        showStatus('info', `Resumed monitoring ${processingKeywords.length} keywords that were processing before page refresh.`);
      }
    }
  }

  // Run initial checks and formatting  
  setTimeout(() => {
    debugImageStatusSetup();
    // checkImageStatus(); // DISABLED - Caused immediate "failed" status
  }, 1000);
  
  // IMMEDIATE: Start monitoring right away for faster response
  startAutoImageMonitoring();
  
  // BACKUP: Also check again after 1 second in case page wasn't ready
  setTimeout(() => {
    startAutoImageMonitoring();
  }, 1000);
  
  formatDates();
  sortRowsByDate();
  
  // Initialize counts
  updateSelectedCount();
  
  // Check for ongoing processing and restore progress bar if needed
  checkAndRestoreProgressBar().catch(error => {
    console.error('Error in checkAndRestoreProgressBar:', error);
  });
  
  // DISABLED: Old automatic monitoring that caused "failed" status bugs
  // startImageStatusMonitoring();

  // ===== DISCORD IMAGE URL FALLBACK HANDLER =====
  // Handle saving Discord image URL as fallback
  document.querySelectorAll('.save-discord-url-btn').forEach(btn => {
    btn.addEventListener('click', async function() {
      const keywordId = this.getAttribute('data-keyword-id');
      const inputField = document.querySelector(`.discord-image-url-input[data-keyword-id="${keywordId}"]`);
      const discordImageUrl = inputField.value.trim();

      console.log(`üíæ Saving Discord image URL for keyword ${keywordId}:`, discordImageUrl);

      try {
        const response = await fetch('/api/keywords/update-discord-image-url', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            keywordId: keywordId,
            discordImageUrl: discordImageUrl
          })
        });

        const data = await response.json();

        if (data.success) {
          showStatus('success', '‚úÖ Discord image URL saved successfully!');
          this.innerHTML = '<i class="bi bi-check-circle"></i> Saved';
          this.classList.remove('btn-success');
          this.classList.add('btn-outline-success');

          // Reset button after 2 seconds
          setTimeout(() => {
            this.innerHTML = '<i class="bi bi-check"></i> Save';
            this.classList.remove('btn-outline-success');
            this.classList.add('btn-success');
          }, 2000);
        } else {
          showStatus('error', '‚ùå Failed to save Discord image URL: ' + (data.message || 'Unknown error'));
        }
      } catch (error) {
        console.error('Error saving Discord image URL:', error);
        showStatus('error', '‚ùå Error saving Discord image URL');
      }
    });
  });


});
</script>